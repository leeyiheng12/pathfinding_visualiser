{"version":3,"sources":["App.module.css","components/NodeDisplay.module.css","components/Button.module.css","components/Modal.module.css","components/Grid.module.css","components/NodeDisplay.js","components/Grid.js","components/Node.js","Algorithms/Node.js","Algorithms/Queue.js","Algorithms/Frame.js","Algorithms/PathfindingAlgorithms.js","Algorithms/Stack.js","Algorithms/UnionFind.js","Algorithms/MazeGeneratingAlgorithms.js","App.js","components/Button.js","components/Modal.js","reportWebVitals.js","index.js"],"names":["module","exports","NodeDisplay","React","memo","props","node","nodeClass","rightClass","isStart","classes","startStyle","isEnd","endStyle","isWall","wallStyle","isPath","pathStyle","isClosed","closedStyle","isFrontier","frontierStyle","openStyle","className","onClick","event","preventDefault","rowNum","colNum","onMouseEnter","buttons","onDrag","onMouseDown","e","onContextMenu","prevProp","nextProp","isEqual","Grid","allNodes","gridStyle","ROWS","COLUMNS","onDragHandler","enableInput","thisNode","setWall","updateNode","onClickHandler","startNode","setStartNode","setStart","endNode","setEndNode","setEnd","gridClass","style","map","row","n","Node","rows","cols","this","totalRows","totalCols","isOpen","neighbours","nn","anotherNode","otherDetails","nodeDetails","bool","unpath","allowDiagonal","isTop","isBottom","isLeft","isRight","push","wallNeighbours","mazeNeighbours","node2","key","next","prev","Queue","head","tail","size","setNext","first","Frame","arrNodes","instruction","setFrontier","setOpen","setPath","updateFrontier","updateClosed","updatePath","updateWall","FRONTIER","CLOSED","PATH","WALL","manhattanDistance","point1","point2","Math","abs","getX","getY","euclideanDistance","bestFirstSearch","heuristicFunction","q","FastPriorityQueue","arr1","arr2","add","cameFrom","Map","set","thisFrameFrontierNodes","found","displayFrames","curNode","poll","i","length","neighbour","has","heuristic","x","y","pathFrames","get","reverse","bfs","enqueue","dequeue","aStar","nodesInQ","Set","gScores","fScores","j","Infinity","delete","tempGScore","Stack","nd","UnionFind","arr","p","rank","elmToIdx","elm","findSetHelper","elm1","elm2","findSet","isSameSet","genGrid","aldousBroder","backtracking","binaryTree","growingTree","huntAndKill","kruskal","randomTree","CAMaze","CAMazeCetric","CATest","fillDeadEnds","MAX_LOAD","shuffleArray","array","temp","floor","random","randBetween","a","b","fewRandBetween","results","r","includes","between","genAll","nodes","genWallNeighbours","borders","allWalkable","allNodesCopy","makeCopy","genMazeNeighbours","numRows","numCols","genGridFunc","value","visited","Array","fill","totalNumToVisit","visitedNum","randNeighbour","wall","nodeBetween","stack","f","w","listOfCells","filterFuncGen","noNeighbour","filter","numNodesToVisit","numNodesVisited","allWalls","allSpaces","UFDS","from","space1","space2","unionSet","numWallsToRemove","wallsToRemove","startFrameNodes","lrMid","udMid","randNum","randRow","randCol","c","neverChange","oneFrame","generateNeighbours","changed","thisFrame","numPossibleNeighbours","Button","height","buttonStyle","width","border","hidden","buttonClass","selected","disabled","Backdrop","backdrop","onConfirm","ModalOverlay","modal","header","title","content","message","split","window","open","Modal","ReactDOM","createPortal","document","getElementById","allNodesB","newRow","App","useState","setEnableInput","setAllNodes","updateFrameNodes","frameOfNodes","execute","newAll","slice","nodesToUpdate","getNodes","clearPaths","selectedAlgoName","setAlgo","pfNameToFunc","selectedAlgo","selectedHfName","setHf","hfNameToFunc","selectedHf","setAllowDiagonal","showModal","setShowModal","genMaze","genFunc","clearWalls","result","done","iter","setTimeout","mainDiv","topDiv","section","reset","Object","keys","name","diag","newNodes","searchFrames","numFrames","visualise","reportWebVitals","onPerfEntry","Function","then","getCLS","getFID","getFCP","getLCP","getTTFB","render","StrictMode"],"mappings":"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","file":"static/js/main.16c8e511.chunk.js","sourcesContent":["// extracted by mini-css-extract-plugin\nmodule.exports = {\"mainDiv\":\"App_mainDiv__1bgfA\",\"topDiv\":\"App_topDiv__3J6E3\",\"section\":\"App_section__1bNIh\"};","// extracted by mini-css-extract-plugin\nmodule.exports = {\"nodeClass\":\"NodeDisplay_nodeClass__NYVm6\",\"openStyle\":\"NodeDisplay_openStyle__26E9r\",\"closedStyle\":\"NodeDisplay_closedStyle__GzlFB\",\"wallStyle\":\"NodeDisplay_wallStyle__30I3g\",\"startStyle\":\"NodeDisplay_startStyle__20Pep\",\"endStyle\":\"NodeDisplay_endStyle__12zuf\",\"frontierStyle\":\"NodeDisplay_frontierStyle__2XGHD\",\"pathStyle\":\"NodeDisplay_pathStyle__3ALCR\"};","// extracted by mini-css-extract-plugin\nmodule.exports = {\"buttonClass\":\"Button_buttonClass__B5QHJ\",\"hidden\":\"Button_hidden__2HSR3\",\"selected\":\"Button_selected__13wl8\",\"disabled\":\"Button_disabled__1gUUg\"};","// extracted by mini-css-extract-plugin\nmodule.exports = {\"backdrop\":\"Modal_backdrop__221Tr\",\"modal\":\"Modal_modal__2fjcX\",\"header\":\"Modal_header__1i1nh\",\"content\":\"Modal_content__1zRhD\",\"actions\":\"Modal_actions__1IBXM\"};","// extracted by mini-css-extract-plugin\nmodule.exports = {\"gridClass\":\"Grid_gridClass__ng9hd\"};","import React from \"react\";\r\nimport classes from \"./NodeDisplay.module.css\";\r\n\r\n\r\nconst NodeDisplay = React.memo(props => {\r\n    \r\n    const node = props.nodeClass;\r\n\r\n    const clickHandler = event => {\r\n        event.preventDefault();\r\n        // alert(`${node.rowNum} ${node.colNum}`);\r\n        props.onClick(event, node.rowNum, node.colNum);\r\n    }\r\n    \r\n    // https://developer.mozilla.org/en-US/docs/Web/API/MouseEvent/buttons\r\n    const moveHandler = event => {\r\n        event.preventDefault();\r\n        if (event.buttons === 1 || event.buttons === 2) {\r\n            props.onDrag(event, node.rowNum, node.colNum);\r\n        }\r\n    }\r\n\r\n    const rightClass = node.isStart \r\n        ? classes.startStyle \r\n        : node.isEnd\r\n            ? classes.endStyle\r\n            : node.isWall\r\n                ? classes.wallStyle\r\n                : node.isPath\r\n                    ? classes.pathStyle\r\n                    : node.isClosed\r\n                        ? classes.closedStyle\r\n                        : node.isFrontier\r\n                            ? classes.frontierStyle\r\n                                : classes.openStyle;\r\n\r\n    return (<div className={`${classes.nodeClass} ${rightClass}`}\r\n        onClick={clickHandler}\r\n        onMouseEnter={moveHandler}\r\n        onMouseDown={e => e.preventDefault()}\r\n        onContextMenu={e => e.preventDefault()}\r\n        >\r\n    </div>);\r\n}, (prevProp, nextProp) => prevProp.nodeClass.isEqual(nextProp.nodeClass));\r\n\r\nexport default NodeDisplay;","import React from \"react\";\r\nimport classes from \"./Grid.module.css\";\r\n\r\nimport NodeDisplay from \"./NodeDisplay\";\r\n\r\nconst Grid = props => {\r\n\r\n    const allNodes = props.allNodes;\r\n\r\n    const gridStyle = {\r\n        \"gridTemplateRows\": `repeat(${props.ROWS}, 1fr)`,\r\n        \"gridTemplateColumns\": `repeat(${props.COLUMNS}, 1fr)`\r\n    };\r\n    \r\n    const onDragHandler = (event, rowNum, colNum) => {\r\n        // event.preventDefault();\r\n        if (!props.enableInput) return;\r\n        const thisNode = allNodes[rowNum][colNum];\r\n        if (!thisNode.isStart && !thisNode.isEnd) {\r\n            if (event.buttons === 1) {\r\n                thisNode.setWall(true);\r\n                props.updateNode(thisNode);\r\n            } \r\n            if (event.buttons === 2) {\r\n                thisNode.setWall(false);\r\n                props.updateNode(thisNode);\r\n            }\r\n        }\r\n    }\r\n\r\n    const onClickHandler = (event, rowNum, colNum) => {\r\n        if (!props.enableInput) return;\r\n        const thisNode = allNodes[rowNum][colNum];\r\n        if (!props.startNode && !thisNode.isEnd) {  // haven't selected start\r\n            props.setStartNode(thisNode);\r\n            thisNode.setWall(false);\r\n            thisNode.setStart(true);\r\n        } else if (props.startNode && thisNode.isStart) {  // selected start, it's this\r\n            props.setStartNode(null);\r\n            thisNode.setStart(false);\r\n        } else if (!props.endNode) {  // haven't selected end\r\n            props.setEndNode(thisNode);\r\n            thisNode.setWall(false);\r\n            thisNode.setEnd(true);\r\n        } else if (props.endNode && thisNode.isEnd) {  // selected end, it's this\r\n            props.setEndNode(null);\r\n            thisNode.setEnd(false);\r\n        } else {\r\n            thisNode.setWall(!thisNode.isWall);\r\n        }\r\n        props.updateNode(thisNode);\r\n    }\r\n\r\n    return (<>\r\n        <div className={classes.gridClass} style={gridStyle}>\r\n            {allNodes.map(row => \r\n                row.map(n => <NodeDisplay\r\n                key={2**n.rowNum * 3**n.colNum} \r\n                nodeClass={n}\r\n                onClick={onClickHandler}\r\n                onDrag={onDragHandler} />)\r\n            )}\r\n\r\n        </div>\r\n\r\n    </>);\r\n};\r\n\r\nexport default Grid;","class Node {\r\n    constructor(rows, cols, rowNum, colNum) {  // top left is 0,0\r\n        this.totalRows = rows;\r\n        this.totalCols = cols;\r\n        this.rowNum = rowNum;\r\n        this.colNum = colNum;\r\n\r\n        this.isOpen = true;\r\n        this.isClosed = false;\r\n        this.isWall = false;\r\n        this.isStart = false;\r\n        this.isEnd = false;\r\n        this.isFrontier = false;\r\n        this.isPath = false;\r\n\r\n        this.neighbours = [];\r\n    }\r\n\r\n    // refresh() {\r\n    //     const x = new Node(this.totalRows, this.totalCols, this.rowNum, this.colNum);\r\n    //     x.isOpen = this.isOpen;\r\n    //     x.isWall = this.isWall;\r\n    //     x.isStart = this.isStart;\r\n    //     x.isEnd = this.isEnd;\r\n    //     x.isFrontier = this.isFrontier;\r\n    //     return x;\r\n    // }\r\n\r\n    makeCopy() {\r\n        const nn = new Node(this.totalRows, this.totalCols, this.rowNum, this.colNum);\r\n        nn.isOpen = this.isOpen;\r\n        nn.isClosed = this.isClosed;\r\n        nn.isWall = this.isWall;\r\n        nn.isStart = this.isStart;\r\n        nn.isEnd = this.isEnd;\r\n        nn.isFrontier = this.isFrontier;\r\n        nn.isPath = this.isPath;\r\n        nn.neighbours = this.neighbours;\r\n        return nn;\r\n    }\r\n\r\n    nodeDetails() {\r\n        return {\r\n            \"rowNum\": this.rowNum,\r\n            \"colNum\": this.colNum,\r\n            \"isOpen\": this.isOpen,\r\n            \"isWall\": this.isWall,\r\n            \"isStart\": this.isStart,\r\n            \"isEnd\": this.isEnd,\r\n            \"isFrontier\": this.isFrontier,\r\n        }\r\n    }\r\n\r\n    getX() {\r\n        return this.rowNum;\r\n    }\r\n\r\n    getY() {\r\n        return this.colNum;\r\n    }\r\n\r\n    isEqual(anotherNode) {\r\n        const otherDetails = anotherNode.nodeDetails();\r\n        return this.rowNum === otherDetails.rowNum\r\n        && this.colNum === otherDetails.colNum\r\n        && this.isOpen === otherDetails.isOpen\r\n        && this.isWall === otherDetails.isWall\r\n        && this.isStart === otherDetails.isStart\r\n        && this.isEnd === otherDetails.isEnd\r\n        && this.isFrontier !== otherDetails.isFrontier;\r\n    }\r\n\r\n    toggleOpen() {\r\n        this.isOpen = !this.isOpen;\r\n    }\r\n\r\n    setOpen() {\r\n        this.isOpen = true;\r\n        this.isClosed = false;\r\n    }\r\n\r\n    setClosed() {\r\n        this.isOpen = false;\r\n        this.isClosed = true;\r\n    }\r\n\r\n    setWall(bool) {\r\n        if (bool && (this.isStart || this.isEnd)) return;\r\n        this.isWall = bool;\r\n    }\r\n\r\n    setStart(bool) {\r\n        this.isStart = bool;\r\n    }\r\n\r\n    setEnd(bool) {\r\n        this.isEnd = bool;\r\n    }\r\n\r\n    setFrontier(bool) {\r\n        this.isFrontier = bool;\r\n    }\r\n    \r\n    setPath(bool) {\r\n        this.isPath = bool;\r\n    }\r\n\r\n    reset() {\r\n        this.unpath();\r\n        this.isWall = false;\r\n        this.isStart = false;\r\n        this.isEnd = false;\r\n    }\r\n\r\n    unpath() {\r\n        this.isOpen = true;\r\n        this.isClosed = false;\r\n        this.isFrontier = false;\r\n        this.isPath = false;\r\n    }\r\n\r\n    numPossibleNeighbours() {\r\n        if (this.rowNum === 0 || this.rowNum === this.totalRows - 1) {  // top row or bottom row\r\n            if (this.colNum === 0 || this.colNum === this.totalCols - 1) {  // left most or right most column\r\n                return 2;\r\n            } else return 3;\r\n        } else {  // not top row or bottom row\r\n            if (this.colNum === 0 || this.colNum === this.totalCols - 1) {  // left most or right most column\r\n                return 3;\r\n            } else return 4;\r\n        }\r\n    }\r\n\r\n    generateNeighbours(allNodes, allowDiagonal) {\r\n        this.neighbours = [];\r\n        const isTop = this.rowNum === 0;\r\n        const isBottom = this.rowNum === this.totalRows - 1;\r\n        const isLeft = this.colNum === 0;\r\n        const isRight = this.colNum === this.totalCols - 1;\r\n\r\n        if (!isTop) {\r\n\r\n            if (!allNodes[this.rowNum-1][this.colNum].isWall) \r\n                this.neighbours.push(allNodes[this.rowNum-1][this.colNum]);  // node above it\r\n\r\n            if (allowDiagonal && !isLeft) {\r\n                if (!allNodes[this.rowNum-1][this.colNum-1].isWall) \r\n                    this.neighbours.push(allNodes[this.rowNum-1][this.colNum-1]);  // topleft\r\n            }\r\n\r\n            if (allowDiagonal && !isRight) {\r\n                if (!allNodes[this.rowNum-1][this.colNum+1].isWall) \r\n                    this.neighbours.push(allNodes[this.rowNum-1][this.colNum+1]);  // topright\r\n            }\r\n        }\r\n\r\n        if (!isBottom) {\r\n            if (!allNodes[this.rowNum+1][this.colNum].isWall)\r\n                this.neighbours.push(allNodes[this.rowNum+1][this.colNum]);  // node below it\r\n\r\n            if (allowDiagonal && !isLeft) {\r\n                if (!allNodes[this.rowNum+1][this.colNum-1].isWall)\r\n                this.neighbours.push(allNodes[this.rowNum+1][this.colNum-1]);  // bottomleft\r\n            }\r\n\r\n            if (allowDiagonal && !isRight) {\r\n                if (!allNodes[this.rowNum+1][this.colNum+1].isWall)\r\n                this.neighbours.push(allNodes[this.rowNum+1][this.colNum+1]);  // bottomright\r\n            }\r\n        }\r\n\r\n        if (!isLeft) {\r\n            if (!allNodes[this.rowNum][this.colNum-1].isWall)\r\n                this.neighbours.push(allNodes[this.rowNum][this.colNum-1]);  // node to its left\r\n        }\r\n\r\n        if (!isRight) {\r\n            if (!allNodes[this.rowNum][this.colNum+1].isWall)\r\n                this.neighbours.push(allNodes[this.rowNum][this.colNum+1]);  // node to its right\r\n        }\r\n\r\n        return this.neighbours;\r\n    }\r\n\r\n    genWallNeighbours(allNodes, allowDiagonal) {\r\n        this.wallNeighbours = [];\r\n        const isTop = this.rowNum === 0;\r\n        const isBottom = this.rowNum === this.totalRows - 1;\r\n        const isLeft = this.colNum === 0;\r\n        const isRight = this.colNum === this.totalCols - 1;\r\n\r\n        if (!isTop) {\r\n\r\n            if (allNodes[this.rowNum-1][this.colNum].isWall) \r\n                this.wallNeighbours.push(allNodes[this.rowNum-1][this.colNum]);  // node above it\r\n\r\n            if (allowDiagonal && !isLeft) {\r\n                if (allNodes[this.rowNum-1][this.colNum-1].isWall) \r\n                    this.wallNeighbours.push(allNodes[this.rowNum-1][this.colNum-1]);  // topleft\r\n            }\r\n\r\n            if (allowDiagonal && !isRight) {\r\n                if (allNodes[this.rowNum-1][this.colNum+1].isWall) \r\n                    this.wallNeighbours.push(allNodes[this.rowNum-1][this.colNum+1]);  // topright\r\n            }\r\n        }\r\n\r\n        if (!isBottom) {\r\n            if (allNodes[this.rowNum+1][this.colNum].isWall)\r\n                this.wallNeighbours.push(allNodes[this.rowNum+1][this.colNum]);  // node below it\r\n\r\n            if (allowDiagonal && !isLeft) {\r\n                if (allNodes[this.rowNum+1][this.colNum-1].isWall)\r\n                this.wallNeighbours.push(allNodes[this.rowNum+1][this.colNum-1]);  // bottomleft\r\n            }\r\n\r\n            if (allowDiagonal && !isRight) {\r\n                if (allNodes[this.rowNum+1][this.colNum+1].isWall)\r\n                this.wallNeighbours.push(allNodes[this.rowNum+1][this.colNum+1]);  // bottomright\r\n            }\r\n        }\r\n\r\n        if (!isLeft) {\r\n            if (allNodes[this.rowNum][this.colNum-1].isWall)\r\n                this.wallNeighbours.push(allNodes[this.rowNum][this.colNum-1]);  // node to its left\r\n        }\r\n\r\n        if (!isRight) {\r\n            if (allNodes[this.rowNum][this.colNum+1].isWall)\r\n                this.wallNeighbours.push(allNodes[this.rowNum][this.colNum+1]);  // node to its right\r\n        }\r\n\r\n        return this.wallNeighbours;\r\n    }\r\n\r\n    genMazeNeighbours(allNodes, allowDiagonal) {\r\n        this.mazeNeighbours = [];\r\n        const isTop = this.rowNum === 0 || this.rowNum === 1;\r\n        const isBottom = this.rowNum === this.totalRows - 2 || this.rowNum === this.totalRows - 1;\r\n        const isLeft = this.colNum === 0 || this.colNum === 1;\r\n        const isRight = this.colNum === this.totalCols - 2 || this.colNum === this.totalCols - 1;\r\n\r\n        if (!isTop) {\r\n\r\n            if (!allNodes[this.rowNum-2][this.colNum].isWall) \r\n                this.mazeNeighbours.push(allNodes[this.rowNum-2][this.colNum]);  // node above it\r\n\r\n            if (allowDiagonal && !isLeft) {\r\n                if (!allNodes[this.rowNum-2][this.colNum-2].isWall) \r\n                    this.mazeNeighbours.push(allNodes[this.rowNum-2][this.colNum-2]);  // topleft\r\n            }\r\n\r\n            if (allowDiagonal && !isRight) {\r\n                if (!allNodes[this.rowNum-2][this.colNum+2].isWall) \r\n                    this.mazeNeighbours.push(allNodes[this.rowNum-2][this.colNum+2]);  // topright\r\n            }\r\n        }\r\n\r\n        if (!isBottom) {\r\n            if (!allNodes[this.rowNum+2][this.colNum].isWall)\r\n                this.mazeNeighbours.push(allNodes[this.rowNum+2][this.colNum]);  // node below it\r\n\r\n            if (allowDiagonal && !isLeft) {\r\n                if (!allNodes[this.rowNum+2][this.colNum-2].isWall)\r\n                this.mazeNeighbours.push(allNodes[this.rowNum+2][this.colNum-2]);  // bottomleft\r\n            }\r\n\r\n            if (allowDiagonal && !isRight) {\r\n                if (!allNodes[this.rowNum+2][this.colNum+2].isWall)\r\n                this.mazeNeighbours.push(allNodes[this.rowNum+2][this.colNum+2]);  // bottomright\r\n            }\r\n        }\r\n\r\n        if (!isLeft) {\r\n            if (!allNodes[this.rowNum][this.colNum-2].isWall)\r\n                this.mazeNeighbours.push(allNodes[this.rowNum][this.colNum-2]);  // node to its left\r\n        }\r\n\r\n        if (!isRight) {\r\n            if (!allNodes[this.rowNum][this.colNum+2].isWall)\r\n                this.mazeNeighbours.push(allNodes[this.rowNum][this.colNum+2]);  // node to its right\r\n        }\r\n        return this.mazeNeighbours;\r\n    }\r\n\r\n    nodeBetween(allNodes, node2) {\r\n        if (this.rowNum === node2.rowNum) {\r\n            return allNodes[this.rowNum][(this.colNum + node2.colNum)/2];\r\n        } else {\r\n            return allNodes[(this.rowNum + node2.rowNum)/2][this.colNum];\r\n        }\r\n    }\r\n}\r\n\r\nexport default Node;","class Node {\r\n    constructor(key) {\r\n        this.key = key;\r\n        this.next = null;\r\n        this.prev = null;\r\n    }\r\n\r\n    setNext(n) {\r\n        this.next = n;\r\n    }\r\n\r\n    setPrev(n) {\r\n        this.prev = n;\r\n    }\r\n}\r\n\r\nexport default Node;","import Node from \"./Node\";\r\n\r\nclass Queue {\r\n    constructor() {\r\n        this.head = null;\r\n        this.tail = null;\r\n        this.size = 0;\r\n    }\r\n\r\n    enqueue(n) {\r\n        if (this.head === null) {\r\n            this.head = new Node(n);\r\n            this.tail = this.head;\r\n        } else {\r\n            this.tail.setNext(new Node(n));\r\n            this.tail = this.tail.next;\r\n        }\r\n        this.size++;\r\n    }\r\n\r\n    dequeue() {\r\n        const first = this.head;\r\n        this.head = this.head.next;\r\n        this.size--;\r\n        return first.key;\r\n    }\r\n\r\n    length() {\r\n        return this.size;\r\n    }\r\n}\r\n\r\nexport default Queue;","\r\nclass Frame {\r\n    static FRONTIER = 1;\r\n    static CLOSED = 2;\r\n    static PATH = 3;\r\n    static WALL = 4;\r\n    \r\n    constructor(arrNodes, instruction) {\r\n        this.arrNodes = arrNodes;\r\n        this.instruction = instruction;\r\n    }\r\n\r\n    getNodes() {\r\n        return this.arrNodes;\r\n    }\r\n\r\n    updateFrontier() {\r\n        for (const node of this.arrNodes) {\r\n            node.setFrontier(true);\r\n        }\r\n    }\r\n\r\n    updateClosed() {\r\n        for (const node of this.arrNodes) {\r\n            node.setOpen(false);\r\n        }\r\n    }\r\n\r\n    updatePath() {\r\n        for (const node of this.arrNodes) {\r\n            node.setPath(true);\r\n        }\r\n    }\r\n\r\n    updateWall() {\r\n        for (const node of this.arrNodes) {\r\n            node.setWall(true);\r\n        }\r\n    }\r\n\r\n    execute() {\r\n        if (this.instruction === 1) this.updateFrontier();\r\n        if (this.instruction === 2) this.updateClosed();\r\n        if (this.instruction === 3) this.updatePath();\r\n        if (this.instruction === 4) this.updateWall();\r\n    }\r\n}\r\n\r\nexport default Frame;","import Queue from \"./Queue\";\r\nimport FastPriorityQueue from \"fastpriorityqueue\";\r\nimport Frame from \"./Frame\";\r\n\r\n\r\nexport function manhattanDistance(point1, point2) {\r\n    return Math.abs(point1.getX()-point2.getX()) + Math.abs(point1.getY()-point2.getY());\r\n}\r\n\r\n\r\nexport function euclideanDistance(point1, point2) {\r\n    return ((point1.getX() - point2.getX()) ** 2 + (point1.getY() - point2.getY()) ** 2) ** 0.5\r\n}\r\n\r\nexport function bestFirstSearch(startNode, endNode, allNodes, heuristicFunction) {\r\n\r\n    // https://github.com/lemire/FastPriorityQueue.js/\r\n    const q = new FastPriorityQueue((arr1, arr2) => arr1[1] < arr2[1]);\r\n    q.add([startNode, 0]);\r\n\r\n    const cameFrom = new Map();\r\n    cameFrom.set(startNode, null);\r\n\r\n    let found = false;\r\n\r\n    let displayFrames = [];\r\n    let thisFrameFrontierNodes;\r\n\r\n    while (q.size > 0 && !found) {\r\n        const output = q.poll();\r\n        const curNode = output[0];  // since I insert [node, priority]\r\n        if (!curNode.neighbours) continue;\r\n\r\n        thisFrameFrontierNodes = [];  // for visualisation purposes\r\n        for (let i = 0; i < curNode.neighbours.length && !found; i++) {\r\n            let neighbour = curNode.neighbours[i];\r\n            if (neighbour.isEnd) {\r\n                endNode = neighbour;\r\n                cameFrom.set(endNode, curNode);\r\n                found = true;  // end early\r\n            }\r\n            if (!cameFrom.has(neighbour)) {  // has not been evaluated before\r\n                cameFrom.set(neighbour, curNode);  // remember where it came from\r\n                thisFrameFrontierNodes.push(neighbour);  // for visualisation\r\n                const heuristic = heuristicFunction(neighbour, endNode);\r\n                q.add([neighbour, heuristic]);\r\n            }\r\n        }\r\n\r\n        // at this frame, the frontier nodes should light up\r\n        const x = new Frame(thisFrameFrontierNodes, Frame.FRONTIER);\r\n        displayFrames.push(x);\r\n        \r\n        // at this frame, the visited node should be displayed as closed\r\n        const y = new Frame([curNode], Frame.CLOSED)\r\n        displayFrames.push(y);\r\n    }\r\n\r\n    if (!found) return [displayFrames, null];\r\n\r\n    // for visualisation\r\n    const pathFrames = [];\r\n    for (let i = 1; endNode !== null; i++) {\r\n        pathFrames.push(new Frame([endNode], Frame.PATH));\r\n        endNode = cameFrom.get(endNode);\r\n    }\r\n    pathFrames.reverse();\r\n\r\n    // want to return an array of 2 arrays\r\n    // first array is array of Frames showing the visualisation of pathfinding, to be shown first\r\n    // second array is array of Frames showing the final path\r\n    return [displayFrames, pathFrames];\r\n}\r\n\r\n\r\nexport function bfs(startNode, endNode, allNodes, heuristicFunction) {\r\n\r\n    const q = new Queue();\r\n    q.enqueue(startNode);\r\n\r\n    const cameFrom = new Map();\r\n    cameFrom.set(startNode, null);\r\n\r\n    let found = false;\r\n\r\n    let displayFrames = [];\r\n    let thisFrameFrontierNodes;\r\n\r\n    while (q.length() > 0 && !found) {\r\n        const curNode = q.dequeue();\r\n        if (curNode.neighbours === null) continue;\r\n\r\n        thisFrameFrontierNodes = [];  // for visualisation purposes\r\n        for (let i = 0; i < curNode.neighbours.length && !found; i++) {\r\n            let neighbour = curNode.neighbours[i];\r\n            if (neighbour.isEnd) {\r\n                endNode = neighbour;\r\n                cameFrom.set(endNode, curNode);\r\n                found = true;  // end early\r\n            }\r\n            if (!cameFrom.has(neighbour)) {  // has not been evaluated before\r\n                cameFrom.set(neighbour, curNode);  // remember where it came from\r\n                thisFrameFrontierNodes.push(neighbour);  // for visualisation\r\n                q.enqueue(neighbour);\r\n            }\r\n        }\r\n        // at this frame, the frontier nodes should light up\r\n        const x = new Frame(thisFrameFrontierNodes, Frame.FRONTIER);\r\n        displayFrames.push(x);\r\n        \r\n        // at this frame, the visited node should be displayed as closed\r\n        const y = new Frame([curNode], Frame.CLOSED)\r\n        displayFrames.push(y);\r\n    }\r\n\r\n    if (!found) return [displayFrames, null];\r\n\r\n    // for visualisation\r\n    const pathFrames = [];\r\n    for (let i = 1; endNode !== null; i++) {\r\n        pathFrames.push(new Frame([endNode], Frame.PATH));\r\n        endNode = cameFrom.get(endNode);\r\n    }\r\n    pathFrames.reverse();\r\n\r\n    return [displayFrames, pathFrames];\r\n}\r\n\r\nexport function aStar(startNode, endNode, allNodes, heuristicFunction) {\r\n\r\n    // https://github.com/lemire/FastPriorityQueue.js/\r\n    const q = new FastPriorityQueue((arr1, arr2) => arr1[1] < arr2[1]);  // open list\r\n    q.add([startNode, 0]);\r\n\r\n    const nodesInQ = new Set();\r\n    nodesInQ.add(startNode);\r\n\r\n    const cameFrom = new Map();\r\n    cameFrom.set(startNode, null);\r\n\r\n    const gScores = new Map();  // movement cost from startNode\r\n    const fScores = new Map();\r\n    for (let i = 0; i < allNodes.length; i++) {\r\n        for (let j = 0; j < allNodes[i].length; j++) {\r\n            gScores.set(allNodes[i][j], Infinity);\r\n            fScores.set(allNodes[i][j], Infinity);\r\n        }\r\n    }\r\n\r\n    gScores.set(startNode, 0);\r\n    gScores.set(startNode, heuristicFunction(startNode, endNode));\r\n\r\n    let found = false;\r\n\r\n    let displayFrames = [];\r\n    let thisFrameFrontierNodes;\r\n\r\n    while (q.size > 0 && !found) {\r\n        const output = q.poll();\r\n        const curNode = output[0];  // since I insert [node, priority]\r\n        nodesInQ.delete(curNode);\r\n\r\n        if (curNode.neighbours === null) continue;\r\n\r\n        thisFrameFrontierNodes = [];  // for visualisation purposes\r\n\r\n        for (let i = 0; i < curNode.neighbours.length && !found; i++) {\r\n            let neighbour = curNode.neighbours[i];\r\n            if (neighbour.isEnd) {\r\n                endNode = neighbour;\r\n                cameFrom.set(endNode, curNode);\r\n                found = true;  // end early\r\n            }\r\n            \r\n            const tempGScore = gScores.get(curNode) + heuristicFunction(curNode, neighbour);  // weight of edge from current to neighbour\r\n            if (tempGScore < gScores.get(neighbour)) {  // this is a better path\r\n                cameFrom.set(neighbour, curNode);\r\n                gScores.set(neighbour, tempGScore);\r\n                fScores.set(neighbour, tempGScore + heuristicFunction(neighbour, endNode));\r\n                if (!nodesInQ.has(neighbour)) {  // neighbour not in priority queue\r\n                    q.add([neighbour, fScores.get(neighbour)]);\r\n                    nodesInQ.add(neighbour);\r\n                    thisFrameFrontierNodes.push(neighbour);  // for visualisation\r\n                }\r\n            }\r\n        }\r\n\r\n        // at this frame, the frontier nodes should light up\r\n        const x = new Frame(thisFrameFrontierNodes, Frame.FRONTIER);\r\n        displayFrames.push(x);\r\n        \r\n        // at this frame, the visited node should be displayed as closed\r\n        const y = new Frame([curNode], Frame.CLOSED)\r\n        displayFrames.push(y);\r\n    }\r\n\r\n    if (!found) return [displayFrames, null];\r\n\r\n    // for visualisation\r\n    const pathFrames = [];\r\n    for (let i = 1; endNode !== null; i++) {\r\n        pathFrames.push(new Frame([endNode], Frame.PATH));\r\n        endNode = cameFrom.get(endNode);\r\n    }\r\n    pathFrames.reverse();\r\n\r\n    // want to return an array of 2 arrays\r\n    // first array is array of Frames showing the visualisation of pathfinding, to be shown first\r\n    // second array is array of Frames showing the final path\r\n    return [displayFrames, pathFrames];\r\n}","import Node from \"./Node\";\r\n\r\nclass Stack {\r\n    constructor() {\r\n        this.head = null;\r\n        this.tail = null;\r\n        this.size = 0;\r\n    }\r\n\r\n    enqueue(n) {\r\n        const nd = new Node(n);\r\n        if (this.head === null) {\r\n            this.head = nd;\r\n            this.tail = this.head;\r\n        } else {\r\n            nd.setNext(this.head);\r\n            this.head = nd;\r\n        }\r\n        this.size++;\r\n    }\r\n\r\n    dequeue() {\r\n        const first = this.head;\r\n        this.head = this.head.next;\r\n        this.size--;\r\n        return first.key;\r\n    }\r\n\r\n    length() {\r\n        return this.size;\r\n    }\r\n}\r\n\r\nexport default Stack;","class UnionFind {\r\n    \r\n    constructor(arr) {\r\n        this.p = [];\r\n        this.rank = [];\r\n        this.elmToIdx = new Map();\r\n        for (let i = 0; i < arr.length; i++) {\r\n            this.p[i] = i;\r\n            this.rank[i] = 0;\r\n            this.elmToIdx.set(arr[i], i);\r\n        }\r\n    }\r\n\r\n    findSet(elm) {\r\n        return this.findSetHelper(this.elmToIdx.get(elm));\r\n    }\r\n\r\n    findSetHelper(i) {\r\n        if (this.p[i] === i) return i;\r\n        else {\r\n            this.p[i] = this.findSetHelper(this.p[i]);\r\n            return this.p[i]; \r\n        } \r\n    }\r\n\r\n    isSameSet(elm1, elm2) { \r\n        return this.findSet(elm1) === this.findSet(elm2); \r\n    }\r\n\r\n    unionSet(elm1, elm2) { \r\n        if (!this.isSameSet(elm1, elm2)) { \r\n            const x = this.findSet(elm1);\r\n            const y = this.findSet(elm2);\r\n            // rank is used to keep the tree short\r\n            if (this.rank[x] > this.rank[y]) \r\n                this.p[y] = x;\r\n            else { \r\n                this.p[x] = y;\r\n                if (this.rank[x] === this.rank[y]) \r\n                    this.rank[y] = this.rank[y]+1; \r\n            } \r\n        } \r\n    }\r\n}\r\n\r\nexport default UnionFind;","import Frame from \"./Frame\";\r\nimport Stack from \"./Stack\";\r\nimport UnionFind from \"./UnionFind\";\r\n\r\nconst MAX_LOAD = 100;\r\n\r\n\r\nfunction shuffleArray(array) {\r\n    let temp;\r\n    for (let i = array.length - 1; i > 0; i--) {\r\n        // Generate random number\r\n        let j = Math.floor(Math.random() * (i + 1));         \r\n        temp = array[i];\r\n        array[i] = array[j];\r\n        array[j] = temp;\r\n    }\r\n        \r\n    return array;\r\n}\r\n\r\nfunction randBetween(a, b) {\r\n    return Math.floor(Math.random() * (b-a)) + a;\r\n}\r\n\r\nfunction fewRandBetween(a, b, n) {\r\n    const results = [];\r\n    for (let i = 0; i < n; i++) {\r\n        let r = randBetween(a, b);\r\n        while (results.includes(r)) {\r\n            r = randBetween(a, b);\r\n        }\r\n        results.push(r);\r\n    }\r\n    return results;\r\n}\r\n\r\nfunction between(a, b) {\r\n    return Math.floor((b-a)/2);\r\n}\r\n\r\nfunction genAll(nodes) {  // generate all wall neighbours for each node\r\n    for (let i = 0; i < nodes.length; i++) {\r\n        for (let j = 0; j < nodes[0].length; j++) {\r\n            nodes[i][j].genWallNeighbours(nodes, true);\r\n        }\r\n    }\r\n    return nodes;\r\n}\r\n\r\nfunction * genGrid(allNodes) {  // generates the grid, returning the empty walkable nodes\r\n    const borders = [];\r\n    let allWalkable = [];\r\n    const allNodesCopy = allNodes.map(i => i.map(n => n.makeCopy()));\r\n    for (let i = 0; i < allNodesCopy.length; i++) {\r\n        for (let j = 0; j < allNodesCopy[0].length; j++) {\r\n            if (i % 2 === 0 || j % 2 === 0) {\r\n                allNodesCopy[i][j].setWall(true);\r\n                borders.push(allNodesCopy[i][j]);\r\n            } else {\r\n                allNodesCopy[i][j].genMazeNeighbours(allNodesCopy, false);\r\n                allWalkable.push(allNodesCopy[i][j]);\r\n            }\r\n        }\r\n    }\r\n    yield new Frame(borders);\r\n    return allWalkable;\r\n}\r\n\r\nexport function * aldousBroder(allNodes) {\r\n\r\n    const numRows = allNodes.length;\r\n    const numCols = allNodes[0].length;\r\n\r\n   const genGridFunc = genGrid(allNodes);\r\n   yield genGridFunc.next().value;\r\n   const allWalkable = genGridFunc.next().value;\r\n\r\n    const visited = [];\r\n    for (let i = 0; i < numRows; i++) visited.push(new Array(numCols).fill(false));\r\n\r\n    const totalNumToVisit = allWalkable.length;\r\n    let curNode = allWalkable[randBetween(0, allWalkable.length)];\r\n    let visitedNum = 1;\r\n    let randNeighbour, wall;\r\n\r\n    while (visitedNum !== totalNumToVisit) {\r\n        randNeighbour = curNode.mazeNeighbours[randBetween(0, curNode.mazeNeighbours.length)];\r\n        if (!visited[randNeighbour.rowNum][randNeighbour.colNum]) {\r\n            visited[randNeighbour.rowNum][randNeighbour.colNum] = true;\r\n            visitedNum++;\r\n            wall = curNode.nodeBetween(allNodes, randNeighbour);\r\n            wall.setWall(false);\r\n            yield new Frame([wall]);\r\n        }\r\n        curNode = randNeighbour;\r\n    }\r\n    \r\n}\r\n\r\nexport function * backtracking(allNodes) {\r\n\r\n    const numRows = allNodes.length;\r\n    const numCols = allNodes[0].length;\r\n\r\n    const genGridFunc = genGrid(allNodes);\r\n    yield genGridFunc.next().value;\r\n    const allWalkable = genGridFunc.next().value;\r\n\r\n    const visited = [];\r\n    for (let i = 0; i < numRows; i++) visited.push(new Array(numCols).fill(false));\r\n    \r\n    let stack = new Stack();\r\n    let randNeighbour;\r\n    let curNode = allWalkable[randBetween(0, allWalkable.length)];\r\n    shuffleArray(curNode.mazeNeighbours);\r\n    for (randNeighbour of curNode.mazeNeighbours) {\r\n        stack.enqueue([randNeighbour, curNode]);\r\n    }\r\n\r\n    visited[curNode.rowNum][curNode.colNum] = true;\r\n    let wall;\r\n    while (stack.length() > 0) {\r\n        [randNeighbour, curNode] = stack.dequeue();\r\n        if (visited[randNeighbour.rowNum][randNeighbour.colNum]) continue;\r\n        visited[randNeighbour.rowNum][randNeighbour.colNum] = true;\r\n\r\n        // break wall\r\n        wall = randNeighbour.nodeBetween(allNodes, curNode);\r\n        wall.setWall(false);\r\n        yield new Frame([wall]);\r\n\r\n        curNode = randNeighbour;\r\n        shuffleArray(curNode.mazeNeighbours);\r\n        for (randNeighbour of curNode.mazeNeighbours) {\r\n            stack.enqueue([randNeighbour, curNode]);\r\n        }\r\n    }\r\n}\r\n\r\nexport function * binaryTree(allNodes) {\r\n\r\n    // ======================== grids ========================\r\n \r\n    const genGridFunc = genGrid(allNodes);\r\n    yield genGridFunc.next().value;\r\n    const allWalkable = genGridFunc.next().value;\r\n \r\n     for (let i = 0; i < allWalkable.length; i++) {\r\n         const curNode = allWalkable[i];\r\n         let n;\r\n \r\n         // north or west\r\n         let w = randBetween(1, 3) % 2;\r\n         if (w === 0) {  // north\r\n             if (curNode.rowNum > 1) n = allNodes[curNode.rowNum-1][curNode.colNum];\r\n         }  // west\r\n         if (w === 1) {\r\n             if (curNode.colNum > 1) n = allNodes[curNode.rowNum][curNode.colNum-1]\r\n         }\r\n \r\n         if (n) {\r\n             n.setWall(false);\r\n             yield new Frame([n]);\r\n         }\r\n     }\r\n}\r\n\r\nexport function * growingTree(allNodes) {\r\n\r\n    const numRows = allNodes.length;\r\n    const numCols = allNodes[0].length;\r\n\r\n   // ======================== grids ========================\r\n\r\n    const genGridFunc = genGrid(allNodes);\r\n    yield genGridFunc.next().value;\r\n    const allWalkable = genGridFunc.next().value;\r\n\r\n    const visited = [];\r\n    for (let i = 0; i < numRows; i++) visited.push(new Array(numCols).fill(false));\r\n\r\n    let curNode = allWalkable[randBetween(0, allWalkable.length)];\r\n    let listOfCells = [curNode];\r\n\r\n    let noNeighbour;\r\n    let randNeighbour;\r\n    let wall;\r\n\r\n    let filterFuncGen = node => x => x!==node;\r\n\r\n    while (true) {\r\n        noNeighbour = true;\r\n        curNode = listOfCells[randBetween(0, listOfCells.length)];\r\n        visited[curNode.rowNum][curNode.colNum] = true;\r\n\r\n        shuffleArray(curNode.mazeNeighbours);\r\n        for (randNeighbour of curNode.mazeNeighbours) {\r\n            if (!visited[randNeighbour.rowNum][randNeighbour.colNum]) {\r\n\r\n                // make wakk\r\n                wall = curNode.nodeBetween(allNodes, randNeighbour);\r\n                wall.setWall(false);\r\n                yield new Frame([wall]);\r\n\r\n                // add to list\r\n                listOfCells.push(randNeighbour);\r\n\r\n                noNeighbour = false;\r\n                break;\r\n            }\r\n        }\r\n        if (noNeighbour) {  // remove from array\r\n            listOfCells = listOfCells.filter(filterFuncGen(curNode));\r\n        }\r\n        if (listOfCells.length === 0) break;\r\n    }\r\n}\r\n\r\nexport function * huntAndKill(allNodes) {\r\n\r\n    const numRows = allNodes.length;\r\n    const numCols = allNodes[0].length;\r\n\r\n   // ======================== grids ========================\r\n\r\n    const genGridFunc = genGrid(allNodes);\r\n    yield genGridFunc.next().value;\r\n    const allWalkable = genGridFunc.next().value;\r\n\r\n    const visited = [];\r\n    for (let i = 0; i < numRows; i++) visited.push(new Array(numCols).fill(false));\r\n\r\n    const numNodesToVisit = allWalkable.length;\r\n    let numNodesVisited = 0;\r\n\r\n    let curNode = allWalkable[randBetween(0, allWalkable.length)];\r\n    let noNeighbour;\r\n    let wall;\r\n    let randNeighbour;\r\n\r\n    while (true) {\r\n\r\n        if (!visited[curNode.rowNum][curNode.colNum]) {\r\n            visited[curNode.rowNum][curNode.colNum] = true;\r\n            numNodesVisited++;\r\n        }\r\n\r\n        noNeighbour = true;\r\n        shuffleArray(curNode.mazeNeighbours);\r\n\r\n        for (randNeighbour of curNode.mazeNeighbours) {\r\n            if (!visited[randNeighbour.rowNum][randNeighbour.colNum]) {\r\n                noNeighbour = false;\r\n                \r\n                wall = curNode.nodeBetween(allNodes, randNeighbour);\r\n                wall.setWall(false);\r\n                yield new Frame([wall]);\r\n                \r\n                // this is next curNode\r\n                curNode = randNeighbour;\r\n                break;\r\n            }\r\n        }\r\n\r\n        if (noNeighbour) {\r\n            while (true) {\r\n                curNode = allWalkable[randBetween(0, allWalkable.length)];\r\n                if (visited[curNode.rowNum][curNode.colNum]) break;\r\n            } \r\n        }\r\n\r\n        if (numNodesVisited === numNodesToVisit) break;\r\n    }\r\n}\r\n\r\nexport function * kruskal(allNodes) {\r\n\r\n    const numRows = allNodes.length;\r\n    const numCols = allNodes[0].length;\r\n\r\n   // ======================== grids ========================\r\n\r\n    const genGridFunc = genGrid(allNodes);\r\n    yield genGridFunc.next().value;\r\n    // const allWalkable = genGridFunc.next().value;\r\n\r\n    const visited = [];\r\n    for (let i = 0; i < numRows; i++) visited.push(new Array(numCols).fill(false));\r\n\r\n    // contains a bunch of arrays\r\n    // each array has 3 nodes: a wall, and the 2 nodes it divides\r\n    let allWalls = [];  \r\n    for (let i = 0; i < numRows; i++) {\r\n        for (let j = 0; j < numCols; j++) {\r\n            if (i !== 0 && i !== numRows -1) {\r\n                if (j !== 0 && j !== numCols - 1) {\r\n                    \r\n                    if (i % 2 === 1 && j % 2 === 0) {  // its left and right are paths\r\n                        allWalls.push([allNodes[i][j], allNodes[i][j-1], allNodes[i][j+1]]);\r\n                    } else if (i % 2 === 0 && j % 2 === 1) {  // its up and down are paths\r\n                        allWalls.push([allNodes[i][j], allNodes[i-1][j], allNodes[i+1][j]]);\r\n                    }\r\n\r\n                }\r\n            }\r\n        }\r\n    }\r\n\r\n    const allSpaces = new Set();\r\n    for (let i = 0; i < allWalls.length; i++) {\r\n        allSpaces.add(allWalls[i][1]);\r\n        allSpaces.add(allWalls[i][2]);\r\n    }\r\n    const UFDS = new UnionFind(Array.from(allSpaces));\r\n    allWalls = shuffleArray(allWalls);\r\n\r\n    let wall, space1, space2;\r\n\r\n    for (let i = 0; i < allWalls.length; i++) {\r\n        [wall, space1, space2] = allWalls[i];\r\n        if (!UFDS.isSameSet(space1, space2)) {\r\n            UFDS.unionSet(space1, space2);\r\n            wall.setWall(false);\r\n            yield new Frame([wall]);\r\n        }\r\n    }\r\n}\r\n\r\nexport function * randomTree(allNodes) {\r\n\r\n    const numRows = allNodes.length;\r\n    const numCols = allNodes[0].length;\r\n\r\n   // ======================== grids ========================\r\n\r\n   const genGridFunc = genGrid(allNodes);\r\n   yield genGridFunc.next().value;\r\n   const allWalkable = genGridFunc.next().value;\r\n\r\n    for (let i = 0; i < allWalkable.length; i++) {\r\n        const curNode = allWalkable[i];\r\n\r\n        // random number\r\n        let numWallsToRemove = randBetween(1, 4);\r\n        let wallsToRemove = fewRandBetween(0, 4, numWallsToRemove);\r\n        for (const w of wallsToRemove) {\r\n            let n;\r\n            if (w === 0 && curNode.rowNum > 1) n = allNodes[curNode.rowNum-1][curNode.colNum];\r\n            else if (w === 1 && curNode.colNum < numCols-2) n = allNodes[curNode.rowNum][curNode.colNum+1];\r\n            else if (w === 2 && curNode.rowNum < numRows-2) n = allNodes[curNode.rowNum+1][curNode.colNum];\r\n            else if (w === 3 && curNode.colNum > 1) n = allNodes[curNode.rowNum][curNode.colNum-1];\r\n            if (!n) continue;\r\n            n.setWall(false);\r\n            yield new Frame([n]);\r\n        }\r\n    }\r\n}\r\n\r\nexport function * CAMaze(allNodes) {\r\n\r\n    // https://www.conwaylife.com/wiki/OCA:Maze\r\n    //  rulestring B3/S12345)\r\n\r\n    const numRows = allNodes.length;\r\n    const numCols = allNodes[0].length;\r\n\r\n    let allNodesCopy = allNodes.map(i => i.map(n => n.makeCopy()));\r\n\r\n    // ======================== random start? ========================\r\n\r\n    const startFrameNodes = [];\r\n    const lrMid = between(0, numCols - 1);\r\n    const udMid = between(0, numRows - 1);\r\n    const randNum = randBetween(5, 7);\r\n    for (let i = 0; i < randNum; i++) {\r\n        const randRow = randBetween(udMid - 1, udMid + 2);\r\n        const randCol = randBetween(lrMid - 1, lrMid + 2);\r\n        if (allNodesCopy[randRow][randCol].isWall) {\r\n            i --;\r\n            continue;\r\n        }\r\n        allNodesCopy[randRow][randCol].setWall(true);\r\n        startFrameNodes.push(allNodesCopy[randRow][randCol]);\r\n    }\r\n    yield new Frame(startFrameNodes, Frame.WALL);\r\n\r\n    // ======================== CA? ========================\r\n\r\n    let neverChange;\r\n    let curNode;\r\n\r\n    for (let c = 0; c < MAX_LOAD; c++) {\r\n        neverChange = true;\r\n        const oneFrame = [];\r\n        genAll(allNodesCopy);  // regenerate neighbours\r\n        for (let i = 0; i < numRows; i++) {\r\n            for (let j = 0; j < numCols; j++) {\r\n                curNode = allNodesCopy[i][j];\r\n                \r\n                // if dead, and have 3 live neighbours, come alive\r\n                if (!curNode.isWall) {\r\n                    if (curNode.wallNeighbours.length === 3) {\r\n                        curNode.setWall(true);\r\n                        oneFrame.push(curNode);\r\n                        neverChange = false;\r\n                    }\r\n                } else {  // if alive, stay alive if 1-5 neighbours\r\n                    if (curNode.wallNeighbours.length === 0 || curNode.wallNeighbours.length > 5) {\r\n                        curNode.setWall(false);\r\n                        oneFrame.push(curNode);\r\n                        neverChange = false;\r\n                    }\r\n                }\r\n            }\r\n        }\r\n        if (!neverChange) yield new Frame(oneFrame);\r\n        else c = MAX_LOAD;\r\n    }\r\n    return;\r\n}\r\n\r\nexport function * CAMazeCetric(allNodes) {\r\n\r\n    // https://www.conwaylife.com/wiki/OCA:Maze\r\n    //  rulestring B3/S12345)\r\n\r\n    const numRows = allNodes.length;\r\n    const numCols = allNodes[0].length;\r\n\r\n    let allNodesCopy = allNodes.map(i => i.map(n => n.makeCopy()));\r\n\r\n    // ======================== random start? ========================\r\n\r\n    const startFrameNodes = [];\r\n    const lrMid = between(0, numCols - 1);\r\n    const udMid = between(0, numRows - 1);\r\n    const randNum = randBetween(5, 7);\r\n    for (let i = 0; i < randNum; i++) {\r\n        const randRow = randBetween(udMid - 1, udMid + 2);\r\n        const randCol = randBetween(lrMid - 1, lrMid + 2);\r\n        if (allNodesCopy[randRow][randCol].isWall) {\r\n            i --;\r\n            continue;\r\n        }\r\n        allNodesCopy[randRow][randCol].setWall(true);\r\n        startFrameNodes.push(allNodesCopy[randRow][randCol]);\r\n    }\r\n    yield new Frame(startFrameNodes, Frame.WALL);\r\n\r\n    // ======================== CA? ========================\r\n\r\n    let neverChange;\r\n    let curNode;\r\n\r\n    for (let c = 0; c < MAX_LOAD; c++) {\r\n        neverChange = true;\r\n        const oneFrame = [];\r\n        genAll(allNodesCopy);  // regenerate neighbours\r\n        for (let i = 0; i < numRows; i++) {\r\n            for (let j = 0; j < numCols; j++) {\r\n                curNode = allNodesCopy[i][j];\r\n                \r\n                // if dead, and have 3 live neighbours, come alive\r\n                if (!curNode.isWall) {\r\n                    if (curNode.wallNeighbours.length === 3) {\r\n                        curNode.setWall(true);\r\n                        oneFrame.push(curNode);\r\n                        neverChange = false;\r\n                    }\r\n                } else {  // if alive, stay alive if 1-4 neighbours, mazeCentric is 4\r\n                    if (curNode.wallNeighbours.length === 0 || curNode.wallNeighbours.length > 4) {\r\n                        curNode.setWall(false);\r\n                        oneFrame.push(curNode);\r\n                        neverChange = false;\r\n                    }\r\n                }\r\n            }\r\n        }\r\n        if (!neverChange) yield new Frame(oneFrame);\r\n        else c = MAX_LOAD;\r\n    }\r\n    return;\r\n}\r\n\r\nexport function * CATest(allNodes) {\r\n\r\n    // https://www.conwaylife.com/wiki/OCA:Maze\r\n    //  rulestring B3/S12345)\r\n\r\n    const numRows = allNodes.length;\r\n    const numCols = allNodes[0].length;\r\n\r\n    let allNodesCopy = allNodes.map(i => i.map(n => n.makeCopy()));\r\n\r\n    // ======================== random start? ========================\r\n\r\n    const startFrameNodes = [];\r\n    const lrMid = between(0, numCols - 1);\r\n    const udMid = between(0, numRows - 1);\r\n    const randNum = randBetween(5, 7);\r\n    for (let i = 0; i < randNum; i++) {\r\n        const randRow = randBetween(udMid - 1, udMid + 2);\r\n        const randCol = randBetween(lrMid - 1, lrMid + 2);\r\n        if (allNodesCopy[randRow][randCol].isWall) {\r\n            i --;\r\n            continue;\r\n        }\r\n        allNodesCopy[randRow][randCol].setWall(true);\r\n        startFrameNodes.push(allNodesCopy[randRow][randCol]);\r\n    }\r\n    yield new Frame(startFrameNodes, Frame.WALL);\r\n\r\n    // ======================== CA? ========================\r\n\r\n    let neverChange;\r\n    let curNode;\r\n    let oneFrame;\r\n\r\n    // 1, 1-4 interesting\r\n\r\n    for (let c = 0; c < MAX_LOAD; c++) {\r\n        // console.log(c);\r\n        neverChange = true;\r\n        oneFrame = [];\r\n        genAll(allNodesCopy);  // regenerate neighbours\r\n        for (let i = 0; i < numRows; i++) {\r\n            for (let j = 0; j < numCols; j++) {\r\n                curNode = allNodesCopy[i][j];\r\n                \r\n                // if dead, and have 3 live neighbours, come alive\r\n                if (!curNode.isWall) {\r\n                    if (curNode.wallNeighbours.length === 1) {\r\n                        curNode.setWall(true);\r\n                        oneFrame.push(curNode);\r\n                        neverChange = false;\r\n                    }\r\n                } else {  // if alive, stay alive if 1-4 neighbours, mazeCentric is 4, maze is 5\r\n                    if (curNode.wallNeighbours.length === 0 || curNode.wallNeighbours.length > 3) {\r\n                        curNode.setWall(false);\r\n                        oneFrame.push(curNode);\r\n                        neverChange = false;\r\n                    }\r\n                }\r\n            }\r\n        }\r\n        if (!neverChange) yield new Frame(oneFrame);\r\n        else c = MAX_LOAD;\r\n    }\r\n    return;\r\n}\r\n\r\nexport function * fillDeadEnds(allNodes) {\r\n\r\n    const numRows = allNodes.length;\r\n    const numCols = allNodes[0].length;\r\n\r\n    let allNodesCopy = allNodes.map(i => i.map(n => n.makeCopy()));\r\n\r\n    for (let i = 0; i < numRows; i++) {\r\n        for (let j = 0; j < numCols; j++) {\r\n            allNodesCopy[i][j].generateNeighbours(allNodesCopy, false);\r\n        }\r\n    }\r\n\r\n    let changed;\r\n    let thisFrame;\r\n    while (true) {\r\n        for (let i = 0; i < numRows; i++) {\r\n            for (let j = 0; j < numCols; j++) {\r\n                allNodesCopy[i][j].generateNeighbours(allNodesCopy, false);\r\n                allNodesCopy[i][j].genWallNeighbours(allNodesCopy, false);\r\n            }\r\n        }\r\n        changed = false;\r\n        thisFrame = [];\r\n        for (let i = 0; i < numRows; i++) {\r\n            for (let j = 0; j < numCols; j++) {\r\n                const curNode = allNodesCopy[i][j];\r\n                if (curNode.isStart || curNode.isEnd) continue;\r\n                // is not a wall, only 1 neighbour or all neighbours are walls\r\n                if (!curNode.isWall && (curNode.neighbours.length === 1 || curNode.wallNeighbours.length === curNode.numPossibleNeighbours())) {\r\n                    allNodesCopy[i][j].setWall(true);\r\n                    thisFrame.push(allNodesCopy[i][j]);\r\n                    changed = true;\r\n                }\r\n            }\r\n        }\r\n        if (!changed) break;\r\n        yield new Frame(thisFrame, Frame.WALL);\r\n    }\r\n}\r\n\r\n\r\nexport function randCA(allNodes) {\r\n\r\n    const numRows = allNodes.length;\r\n    const numCols = allNodes[0].length;\r\n    const displayFrames = [];\r\n\r\n    let allNodesCopy = allNodes.map(i => i.map(n => n.makeCopy()));\r\n\r\n    function genAll(nodes) {\r\n        for (let i = 0; i < numRows; i++) {\r\n            for (let j = 0; j < numCols; j++) {\r\n                nodes[i][j].genWallNeighbours(nodes, true);\r\n            }\r\n        }\r\n        return nodes;\r\n    }\r\n\r\n    genAll(allNodesCopy);\r\n\r\n    const startFrameNodes = [];\r\n    for (let i = 0; i < 20; i++) {  // 20 random \r\n        const randRow = randBetween(0, numRows);\r\n        const randCol = randBetween(0, numCols);\r\n        allNodesCopy[randRow][randCol].setWall(true);\r\n        startFrameNodes.push(allNodesCopy[randRow][randCol]);\r\n    }\r\n    displayFrames.push(new Frame(startFrameNodes, Frame.WALL));\r\n\r\n    // lets try\r\n    \r\n    for (let c = 0; c < 20; c++) {\r\n        const oneFrame = [];\r\n        genAll(allNodesCopy);  // regenerate neighbours\r\n        for (let i = 0; i < numRows; i++) {\r\n            for (let j = 0; j < numCols; j++) {\r\n                if (allNodesCopy[i][j].wallNeighbours.length >= 1 && allNodesCopy[i][j].wallNeighbours.length <= 2) {\r\n                    if (Math.random() < 0.1) {\r\n                        allNodesCopy[i][j].setWall(true);\r\n                        oneFrame.push(allNodesCopy[i][j]);\r\n                    }\r\n                }\r\n            }\r\n        }\r\n        displayFrames.push(new Frame(oneFrame));\r\n    }\r\n\r\n    return displayFrames;\r\n}\r\n\r\n\r\nexport function randMaze(allNodes) {\r\n\r\n    const numRows = allNodes.length;\r\n    const numCols = allNodes[0].length;\r\n\r\n    let displayFrames = [];\r\n\r\n    function fillRow(rowOrColNum, left, right, up, down) {\r\n        let nodesToChange = [];\r\n        for (let j = left; j < right; j++) {\r\n            // nodesToChange.push(allNodes[rowNum][j]);\r\n            nodesToChange.push(new Frame([allNodes[rowOrColNum][j]], Frame.WALL));\r\n        }\r\n        // remove random one\r\n        // delete nodesToChange[randBetween(left, right)];\r\n        nodesToChange.splice(randBetween(left+1, between(left+1, right-1)), 1);\r\n        nodesToChange.splice(randBetween(between(left+1, right-1), right-1), 1);\r\n        displayFrames = displayFrames.concat(nodesToChange);\r\n        // return nodesToChange.map(n => new Frame([n], Frame.WALL));\r\n        // return new Frame(nodesToChange, Frame.WALL);\r\n    }\r\n\r\n    function fillCol(rowOrColNum, left, right, up, down) {\r\n        const nodesToChange = [];\r\n        for (let i = up; i < down; i++) {\r\n            // nodesToChange.push(allNodes[i][colNum]);\r\n            nodesToChange.push(new Frame([allNodes[i][rowOrColNum]], Frame.WALL));\r\n        }\r\n        // remove random one\r\n        // delete nodesToChange[randBetween(up, down)];\r\n        nodesToChange.splice(randBetween(up+1, between(up+1, down-1)), 1);\r\n        nodesToChange.splice(randBetween(between(up+1, down-1), down-1), 1);\r\n        displayFrames = displayFrames.concat(nodesToChange);\r\n    }\r\n\r\n    function helper(rowOrColNum, l, r, u, d, doRow) {\r\n        // console.log(`${rowOrColNum} ${l} ${r} ${u} ${d}`);\r\n        // if (l+1 === rowOrColNum || rowOrColNum+1 ==) return;\r\n        if (doRow) {\r\n            if (u + 1 >= rowOrColNum || rowOrColNum + 1 >= d) return;\r\n            fillRow(rowOrColNum, l, r, u, d);\r\n            // helper(l + between(l, r), l, r, u, rowOrColNum, !doRow);\r\n            // helper(l + between(l, r), l, r, rowOrColNum+1, d, !doRow);\r\n            const y = between(l, r);\r\n            helper(l + y, l, r, u, rowOrColNum-2, !doRow);\r\n            helper(l + y, l, r, rowOrColNum+2, d, !doRow);\r\n        } else {\r\n            if (l + 1 >= rowOrColNum || rowOrColNum + 1 >= r) return;\r\n            fillCol(rowOrColNum, l, r, u, d);\r\n            const y = between(u, d);\r\n            // helper(u + between(u, d), l, rowOrColNum, u, d, !doRow);\r\n            // helper(u + between(u, d), rowOrColNum+1, r, u, d, !doRow);\r\n            helper(u + y, l, rowOrColNum-2, u, d, !doRow);\r\n            helper(u + y, rowOrColNum+2, r, u, d, !doRow);\r\n        }\r\n    }\r\n\r\n    helper(between(0, numRows), 0, numCols, 0, numRows, true);\r\n\r\n    return displayFrames;\r\n}","import React from \"react\";\n\nimport classes from \"./App.module.css\";\n\nimport Grid from \"./components/Grid\";\nimport Node from \"./components/Node\";\nimport {bfs, bestFirstSearch, aStar} from \"./Algorithms/PathfindingAlgorithms\";\nimport {manhattanDistance, euclideanDistance} from \"./Algorithms/PathfindingAlgorithms\";\nimport {aldousBroder, backtracking, binaryTree, growingTree, huntAndKill, kruskal,\n  randomTree, CAMaze, CAMazeCetric, fillDeadEnds, CATest} from \"./Algorithms/MazeGeneratingAlgorithms\";\n\nimport Button from \"./components/Button\";\nimport Modal from \"./components/Modal\";\n\n\nconst ROWS = 31;\nconst COLUMNS = 61;\nconst SPEED = 1;\n\nconst allNodesB = [];\nfor (let i = 0; i < ROWS; i++) {\n    const newRow = [];\n    for (let j = 0; j < COLUMNS; j++) {\n        newRow.push(new Node(ROWS, COLUMNS, i, j));\n    }\n    allNodesB.push(newRow);\n}\n\n// function deepCopy(allNodes) {\n//   return allNodes.map(i => i.map(n => n.makeCopy()));\n// }\n\nfunction App() {\n\n  const [enableInput, setEnableInput] = React.useState(true);\n  const [allNodes, setAllNodes] = React.useState(allNodesB);\n  const [startNode, setStartNode] = React.useState(null);\n  const [endNode, setEndNode] = React.useState(null);\n\n  function updateSingleNode(node) {\n    const newAll = allNodes.slice();\n    newAll[node.rowNum][node.colNum] = node;\n    setAllNodes(newAll);\n  }\n\n  function updateFrameNodes(frameOfNodes) {  // takes in a frame of nodes\n    // console.log(frameOfNodes);\n    if (!frameOfNodes) return;\n    // console.log(frameOfNodes.getNodes());\n    if (frameOfNodes.instruction) {\n      frameOfNodes.execute();\n    }\n    const newAll = allNodes.slice();\n    const nodesToUpdate = frameOfNodes.getNodes().slice();\n    for (const n of nodesToUpdate) {\n        newAll[n.rowNum][n.colNum] = n;\n    }\n    setAllNodes(newAll);\n  }\n\n  function clearAll(event) {\n    if (!enableInput) return;\n    const newAll = allNodes.slice();\n    for (let i = 0; i < ROWS; i++) {\n      for (let j = 0; j < COLUMNS; j++) {\n        newAll[i][j].reset();\n      }\n    }\n    setAllNodes(newAll);\n    setStartNode(null);\n    setEndNode(null);\n  }\n\n  function clearWalls() {\n    const newAll = allNodes.slice();\n    for (let i = 0; i < ROWS; i++) {\n      for (let j = 0; j < COLUMNS; j++) {\n        newAll[i][j].setWall(false);\n      }\n    }\n    setAllNodes(newAll);\n  }\n\n  function clearPaths() {\n    const newAll = allNodes.slice();\n    for (let i = 0; i < ROWS; i++) {\n      for (let j = 0; j < COLUMNS; j++) {\n        newAll[i][j].unpath();\n      }\n    }\n    setAllNodes(newAll);\n  }\n\n  function generateNeighbours(diag) {\n    const newNodes = allNodes.slice();\n    for (let i = 0; i < ROWS; i++) {\n      for (let j = 0; j < COLUMNS; j++) {\n        newNodes[i][j].generateNeighbours(newNodes, diag);\n      }\n    }\n    setAllNodes(newNodes);\n  }\n\n  function startPathfinding(event) {\n    if (!enableInput) return;\n    if (startNode && endNode) {\n      clearPaths();\n      generateNeighbours(allowDiagonal);\n      startNode.generateNeighbours(allNodes, allowDiagonal);  // ZZZZZZ\n      const [searchFrames, pathFrames] = selectedAlgo(startNode, endNode, allNodes, selectedHf);\n      visualise(searchFrames, pathFrames);\n    }\n  } \n\n  function visualise(searchFrames, pathFrames) {\n    const numFrames = searchFrames.length;\n    for (let i = 0; i < numFrames; i++) {  // for each frame\n      setTimeout(() => {\n        updateFrameNodes(searchFrames[i]);\n        setEnableInput(false);\n      }, i*SPEED);\n    }\n\n    if (!pathFrames) pathFrames = [];\n\n    for (let i = 0; i < pathFrames.length; i++) {\n      setTimeout(\n      () => {\n        setEnableInput(false); \n        updateFrameNodes(pathFrames[i]);\n      }, \n      (searchFrames.length + i) * SPEED\n      );\n    }\n    setTimeout(\n      () => setEnableInput(true), \n      SPEED * (searchFrames.length + pathFrames.length)\n    );\n  }\n\n  const [selectedAlgoName, setAlgo] = React.useState(\"Best First Search\");\n  const pfNameToFunc = {\n    \"BFS\": bfs,\n    \"Best First Search\": bestFirstSearch,\n    \"A* Search\": aStar\n  }\n  const selectedAlgo = pfNameToFunc[selectedAlgoName];\n  \n  const [selectedHfName, setHf] = React.useState(\"Manhattan Distance\");\n  const hfNameToFunc = {\n    \"Manhattan Distance\": manhattanDistance,\n    \"Euclidean Distance\": euclideanDistance,\n  }\n  const selectedHf = hfNameToFunc[selectedHfName];\n\n  const [allowDiagonal, setAllowDiagonal] = React.useState(false);\n\n  const [showModal, setShowModal] = React.useState(false);\n\n  const modalMessage = `\n  Click on a grid square to set the start and end points. \\n\n  Start -> Green \\n\n  End -> Red \\n\n  Wall -> Black \\n\n  To reset a grid square, click on it again.  \\n\n  You can also left-click and drag to draw walls quickly, or right-click and drag to delete walls quickly. \n  Hint: Zoom out all the way if you want the grids to look different.\n  `;\n\n  const genMaze = genFunc => {\n    if (!enableInput) return;\n    clearWalls();\n    clearPaths();\n\n    const displayFrames = genFunc(allNodes);\n    let result = displayFrames.next();\n    let i;\n    for (i = 0; !result.done; i++) {\n      ((r, iter) => \n        setTimeout(() => {\n          updateFrameNodes(r.value);\n          setEnableInput(false);\n        }, iter * SPEED)\n      )(result, i);\n      result = displayFrames.next();\n    }\n    \n    setTimeout(\n      () => {setEnableInput(true);}, \n      SPEED * i\n    );\n  }\n\n  const fillDead = event => {\n    if (!enableInput) return;\n    clearPaths();\n    const displayFrames = fillDeadEnds(allNodes);\n    let result = displayFrames.next();\n    let i;\n    for (i = 0; !result.done; i++) {\n\n      ((r, iter) => \n        setTimeout(() => {\n          updateFrameNodes(r.value);\n          setEnableInput(false);\n        }, iter * SPEED)\n      )(result, i);\n      result = displayFrames.next();\n\n      if (result.done) {\n        setTimeout(\n          () => {setEnableInput(true);}, \n          SPEED * i\n        );\n        return;\n      }\n    }\n   \n\n  }\n\n  return (\n    <div className={classes.mainDiv}>\n\n      {showModal && <Modal onConfirm={e => setShowModal(false)} title=\"Instructions\" message={modalMessage} />}\n\n      <div className={classes.topDiv}>\n       \n        <div className={classes.section}>\n          <Button onClick={e => setShowModal(true)} width=\"5vw\" value=\"Instructions\"></Button>\n          <Button onClick={clearAll} value=\"Clear All\" disabled={!enableInput}></Button>\n        </div>\n\n        <div className={classes.section}>\n          {Object.keys(pfNameToFunc).map(name => <Button \n            onClick={() => setAlgo(name)}\n            value={name} \n            key={name}\n            selected={selectedAlgoName===name} />)\n          }\n        </div>\n        \n        <div className={classes.section}>\n          {Object.keys(hfNameToFunc).map(name => <Button \n            onClick={() => setHf(name)}\n            value={name} \n            key={name}\n            selected={selectedHfName===name} />)\n          }\n        </div>\n\n        <div className={classes.section}>\n          <Button \n            onClick={() => setAllowDiagonal(p=>!p)} \n            width=\"7vw\"\n            value=\"Diagonal Travel\"\n            selected={allowDiagonal}/>\n        </div>\n\n        <div className={classes.section}>\n          <Button onClick={startPathfinding} value=\"Start\" disabled={!enableInput}></Button>\n        </div>\n\n      </div>\n\n      <Grid\n        ROWS={ROWS}\n        COLUMNS={COLUMNS}\n\n        enableInput={enableInput}\n\n        allNodes={allNodes}\n        startNode={startNode}\n        setStartNode={setStartNode}\n        endNode={endNode}\n        setEndNode={setEndNode}\n\n        updateNode={updateSingleNode}\n        />\n\n      <div className={classes.topDiv}>\n        <div className={classes.section}>\n          <Button onClick={e => genMaze(aldousBroder)} value=\"Aldous-Broder\" disabled={!enableInput}></Button>\n          <Button onClick={e => genMaze(backtracking)} value=\"Backtracking\" disabled={!enableInput}></Button>\n          <Button onClick={e => genMaze(binaryTree)} value=\"Binary Tree\" disabled={!enableInput}></Button>\n          <Button onClick={e => genMaze(growingTree)} value=\"Growing Tree\" disabled={!enableInput}></Button>\n          <Button onClick={e => genMaze(huntAndKill)} value=\"Hunt and Kill\" disabled={!enableInput}></Button>\n          <Button onClick={e => genMaze(kruskal)} value=\"Kruskal\" disabled={!enableInput}></Button>\n          <Button onClick={e => genMaze(randomTree)} value=\"Random Tree\" disabled={!enableInput}></Button>\n          <Button onClick={e => genMaze(CAMaze)} width=\"5vw\" value=\"Maze (CA)\" disabled={!enableInput}></Button>\n          <Button onClick={e => genMaze(CAMazeCetric)} width=\"8vw\" value=\"MazeCetric (CA)\" disabled={!enableInput}></Button>\n          <Button onClick={e => genMaze(CATest)} width=\"6vw\" value=\"Another CA\" disabled={!enableInput}></Button>\n        </div>\n\n        <div className={classes.section}>\n          <Button onClick={fillDead} value=\"Fill Dead Ends\" disabled={!enableInput}></Button>\n        </div>\n      </div>\n\n\n    </div>\n\n  );\n}\n\nexport default App;\n","import React from \"react\";\r\nimport classes from \"./Button.module.css\";\r\n\r\n\r\nconst Button = props => {\r\n\r\n    const height = props.height ? props.height : \"6vh\";\r\n    const width = props.width ? props.width : \"6vw\";\r\n\r\n    const buttonStyle = {\r\n        \"width\": width,\r\n        \"height\": height,\r\n        \"border\": props.border,\r\n    }\r\n\r\n    return (<div className={\r\n            `${props.hidden ? classes.hidden : \"\"} \r\n            ${classes.buttonClass} \r\n            ${props.selected ? classes.selected : \"\"}\r\n            ${props.disabled ? classes.disabled : \"\"}`}\r\n        style={buttonStyle} \r\n        onClick={props.onClick}>\r\n\r\n            {props.value}\r\n\r\n        </div>);\r\n}\r\n\r\nexport default Button;","import ReactDOM from \"react-dom\";\r\n\r\n// import Button from \"./Button\";\r\nimport classes from \"./Modal.module.css\";\r\n\r\nconst Backdrop = props => {\r\n    return <div className={classes.backdrop} onClick={props.onConfirm}></div>;\r\n};\r\n\r\nconst ModalOverlay = props => {\r\n    return (\r\n        <div className={classes.modal}>\r\n            <header className={classes.header}>\r\n                <h2>\r\n                    {props.title}\r\n                </h2>\r\n            </header>\r\n            <div className={classes.content}>\r\n                <p>\r\n                    {props.message.split(\"\\n\").map(x => <p>{x}</p>)}\r\n                </p>\r\n                <p onClick={e => window.open(\"https://github.com/leeyiheng12/pathfinding_visualiser\")}>\r\n                    <u>GitHub</u>\r\n                </p>\r\n            </div>\r\n            {/* <footer className={classes.actions}>\r\n                <Button onClick={props.onConfirm}>Ok!</Button>\r\n            </footer> */}\r\n        </div>\r\n    );\r\n};\r\n\r\nconst Modal = props => {\r\n    return (\r\n        <>\r\n            {ReactDOM.createPortal(<Backdrop onConfirm={props.onConfirm} />, document.getElementById(\"backdrop-root\"))}\r\n            {ReactDOM.createPortal(<ModalOverlay title={props.title} message={props.message} onConfirm={props.onConfirm}/>, document.getElementById(\"overlay-root\"))}\r\n        </>\r\n    );\r\n};\r\n\r\nexport default Modal;","const reportWebVitals = onPerfEntry => {\n  if (onPerfEntry && onPerfEntry instanceof Function) {\n    import('web-vitals').then(({ getCLS, getFID, getFCP, getLCP, getTTFB }) => {\n      getCLS(onPerfEntry);\n      getFID(onPerfEntry);\n      getFCP(onPerfEntry);\n      getLCP(onPerfEntry);\n      getTTFB(onPerfEntry);\n    });\n  }\n};\n\nexport default reportWebVitals;\n","import React from 'react';\nimport ReactDOM from 'react-dom';\nimport './index.css';\nimport App from './App';\nimport reportWebVitals from './reportWebVitals';\n\nReactDOM.render(\n  <React.StrictMode>\n    <App />\n  </React.StrictMode>,\n  document.getElementById('root')\n);\n\n// If you want to start measuring performance in your app, pass a function\n// to log results (for example: reportWebVitals(console.log))\n// or send to an analytics endpoint. Learn more: https://bit.ly/CRA-vitals\nreportWebVitals();\n"],"sourceRoot":""}