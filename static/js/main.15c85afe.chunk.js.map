{"version":3,"sources":["App.module.css","components/NodeDisplay.module.css","components/Modal.module.css","components/Button.module.css","components/Grid.module.css","components/NodeDisplay.js","components/Grid.js","components/Node.js","Algorithms/Node.js","Algorithms/Queue.js","Algorithms/Frame.js","Algorithms/PathfindingAlgorithms.js","Algorithms/Stack.js","Algorithms/UnionFind.js","Algorithms/MazeGeneratingAlgorithms.js","App.js","components/Button.js","components/Modal.js","reportWebVitals.js","index.js"],"names":["module","exports","NodeDisplay","React","memo","props","node","nodeClass","rightClass","isStart","classes","startStyle","isEnd","endStyle","isWall","wallStyle","isPath","pathStyle","isClosed","closedStyle","isFrontier","frontierStyle","openStyle","className","onClick","event","preventDefault","rowNum","colNum","onMouseEnter","buttons","onDrag","onMouseDown","e","onContextMenu","prevProp","nextProp","isEqual","Grid","allNodes","gridStyle","ROWS","COLUMNS","onDragHandler","enableInput","thisNode","setWall","updateNode","onClickHandler","startNode","setStartNode","setStart","endNode","setEndNode","setEnd","gridClass","style","map","row","n","Node","rows","cols","this","totalRows","totalCols","isOpen","neighbours","nn","anotherNode","otherDetails","nodeDetails","bool","unpath","allowDiagonal","isTop","isBottom","isLeft","isRight","push","wallNeighbours","mazeNeighbours","node2","key","next","prev","Queue","head","tail","size","setNext","first","Frame","arrNodes","instruction","setFrontier","setOpen","setPath","updateFrontier","updateClosed","updatePath","updateWall","FRONTIER","CLOSED","PATH","WALL","manhattanDistance","point1","point2","Math","abs","getX","getY","euclideanDistance","bestFirstSearch","heuristicFunction","q","FastPriorityQueue","arr1","arr2","add","cameFrom","Map","set","thisFrameFrontierNodes","found","displayFrames","curNode","poll","i","length","neighbour","has","heuristic","x","y","pathFrames","get","reverse","bfs","enqueue","dequeue","aStar","nodesInQ","Set","gScores","fScores","j","Infinity","delete","tempGScore","Stack","nd","UnionFind","arr","p","rank","elmToIdx","elm","findSetHelper","elm1","elm2","findSet","isSameSet","genGrid","genAllWalls","aldousBroder","backtracking","binaryTree","growingTree","huntAndKill","kruskal","prim","wrongGrowingTree","randomTree","CAMaze","CAMazeCetric","CATest","fillDeadEnds","MAX_LOAD","shuffleArray","array","temp","floor","random","randBetween","a","b","fewRandBetween","results","r","includes","between","genAll","nodes","genWallNeighbours","borders","allWalkable","allNodesCopy","makeCopy","genMazeNeighbours","numRows","numCols","genGridFunc","value","visited","Array","fill","totalNumToVisit","visitedNum","randNeighbour","wall","nodeBetween","stack","f","w","listOfCells","filterFuncGen","noNeighbour","randNeighbourCopy","filter","numNodesToVisit","numNodesVisited","allWalls","allSpaces","UFDS","from","space1","space2","unionSet","visitedNodes","pop","unshift","numWallsToRemove","wallsToRemove","startFrameNodes","lrMid","udMid","randNum","randRow","randCol","c","neverChange","oneFrame","generateNeighbours","changed","thisFrame","numPossibleNeighbours","Button","height","buttonStyle","width","border","hidden","buttonClass","selected","disabled","Backdrop","backdrop","onConfirm","ModalOverlay","modal","header","title","content","split","slider","type","min","max","speed","onInput","setSpeed","target","window","open","Modal","ReactDOM","createPortal","document","getElementById","message","allNodesB","newRow","App","useState","setEnableInput","setAllNodes","DURATION","updateFrameNodes","frameOfNodes","execute","newAll","slice","nodesToUpdate","getNodes","clearPaths","selectedAlgoName","setAlgo","pfNameToFunc","selectedAlgo","selectedHfName","setHf","hfNameToFunc","selectedHf","setAllowDiagonal","showModal","setShowModal","genMaze","genFunc","clearWalls","result","done","iter","setTimeout","mainDiv","topDiv","section","reset","Object","keys","name","diag","newNodes","searchFrames","numFrames","visualise","reportWebVitals","onPerfEntry","Function","then","getCLS","getFID","getFCP","getLCP","getTTFB","render","StrictMode"],"mappings":"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","file":"static/js/main.15c85afe.chunk.js","sourcesContent":["// extracted by mini-css-extract-plugin\nmodule.exports = {\"mainDiv\":\"App_mainDiv__1bgfA\",\"topDiv\":\"App_topDiv__3J6E3\",\"section\":\"App_section__1bNIh\"};","// extracted by mini-css-extract-plugin\nmodule.exports = {\"nodeClass\":\"NodeDisplay_nodeClass__NYVm6\",\"openStyle\":\"NodeDisplay_openStyle__26E9r\",\"closedStyle\":\"NodeDisplay_closedStyle__GzlFB\",\"wallStyle\":\"NodeDisplay_wallStyle__30I3g\",\"startStyle\":\"NodeDisplay_startStyle__20Pep\",\"endStyle\":\"NodeDisplay_endStyle__12zuf\",\"frontierStyle\":\"NodeDisplay_frontierStyle__2XGHD\",\"pathStyle\":\"NodeDisplay_pathStyle__3ALCR\"};","// extracted by mini-css-extract-plugin\nmodule.exports = {\"backdrop\":\"Modal_backdrop__221Tr\",\"modal\":\"Modal_modal__2fjcX\",\"header\":\"Modal_header__1i1nh\",\"content\":\"Modal_content__1zRhD\",\"actions\":\"Modal_actions__1IBXM\",\"slider\":\"Modal_slider__3dd9Z\"};","// extracted by mini-css-extract-plugin\nmodule.exports = {\"buttonClass\":\"Button_buttonClass__B5QHJ\",\"hidden\":\"Button_hidden__2HSR3\",\"selected\":\"Button_selected__13wl8\",\"disabled\":\"Button_disabled__1gUUg\"};","// extracted by mini-css-extract-plugin\nmodule.exports = {\"gridClass\":\"Grid_gridClass__ng9hd\"};","import React from \"react\";\r\nimport classes from \"./NodeDisplay.module.css\";\r\n\r\n\r\nconst NodeDisplay = React.memo(props => {\r\n    \r\n    const node = props.nodeClass;\r\n\r\n    const clickHandler = event => {\r\n        event.preventDefault();\r\n        // alert(`${node.rowNum} ${node.colNum}`);\r\n        props.onClick(event, node.rowNum, node.colNum);\r\n    }\r\n    \r\n    // https://developer.mozilla.org/en-US/docs/Web/API/MouseEvent/buttons\r\n    const moveHandler = event => {\r\n        event.preventDefault();\r\n        if (event.buttons === 1 || event.buttons === 2) {\r\n            props.onDrag(event, node.rowNum, node.colNum);\r\n        }\r\n    }\r\n\r\n    const rightClass = node.isStart \r\n        ? classes.startStyle \r\n        : node.isEnd\r\n            ? classes.endStyle\r\n            : node.isWall\r\n                ? classes.wallStyle\r\n                : node.isPath\r\n                    ? classes.pathStyle\r\n                    : node.isClosed\r\n                        ? classes.closedStyle\r\n                        : node.isFrontier\r\n                            ? classes.frontierStyle\r\n                                : classes.openStyle;\r\n\r\n    return (<div className={`${classes.nodeClass} ${rightClass}`}\r\n        onClick={clickHandler}\r\n        onMouseEnter={moveHandler}\r\n        onMouseDown={e => e.preventDefault()}\r\n        onContextMenu={e => e.preventDefault()}\r\n        >\r\n    </div>);\r\n}, (prevProp, nextProp) => prevProp.nodeClass.isEqual(nextProp.nodeClass));\r\n\r\nexport default NodeDisplay;","import React from \"react\";\r\nimport classes from \"./Grid.module.css\";\r\n\r\nimport NodeDisplay from \"./NodeDisplay\";\r\n\r\nconst Grid = props => {\r\n\r\n    const allNodes = props.allNodes;\r\n\r\n    const gridStyle = {\r\n        \"gridTemplateRows\": `repeat(${props.ROWS}, 1fr)`,\r\n        \"gridTemplateColumns\": `repeat(${props.COLUMNS}, 1fr)`\r\n    };\r\n    \r\n    const onDragHandler = (event, rowNum, colNum) => {\r\n        // event.preventDefault();\r\n        if (!props.enableInput) return;\r\n        const thisNode = allNodes[rowNum][colNum];\r\n        if (!thisNode.isStart && !thisNode.isEnd) {\r\n            if (event.buttons === 1) {\r\n                thisNode.setWall(true);\r\n                props.updateNode(thisNode);\r\n            } \r\n            if (event.buttons === 2) {\r\n                thisNode.setWall(false);\r\n                props.updateNode(thisNode);\r\n            }\r\n        }\r\n    }\r\n\r\n    const onClickHandler = (event, rowNum, colNum) => {\r\n        if (!props.enableInput) return;\r\n        const thisNode = allNodes[rowNum][colNum];\r\n        if (!props.startNode && !thisNode.isEnd) {  // haven't selected start\r\n            props.setStartNode(thisNode);\r\n            thisNode.setWall(false);\r\n            thisNode.setStart(true);\r\n        } else if (props.startNode && thisNode.isStart) {  // selected start, it's this\r\n            props.setStartNode(null);\r\n            thisNode.setStart(false);\r\n        } else if (!props.endNode) {  // haven't selected end\r\n            props.setEndNode(thisNode);\r\n            thisNode.setWall(false);\r\n            thisNode.setEnd(true);\r\n        } else if (props.endNode && thisNode.isEnd) {  // selected end, it's this\r\n            props.setEndNode(null);\r\n            thisNode.setEnd(false);\r\n        } else {\r\n            thisNode.setWall(!thisNode.isWall);\r\n        }\r\n        props.updateNode(thisNode);\r\n    }\r\n\r\n    return (<>\r\n        <div className={classes.gridClass} style={gridStyle}>\r\n            {allNodes.map(row => \r\n                row.map(n => <NodeDisplay\r\n                key={2**n.rowNum * 3**n.colNum} \r\n                nodeClass={n}\r\n                onClick={onClickHandler}\r\n                onDrag={onDragHandler} />)\r\n            )}\r\n\r\n        </div>\r\n\r\n    </>);\r\n};\r\n\r\nexport default Grid;","class Node {\r\n    constructor(rows, cols, rowNum, colNum) {  // top left is 0,0\r\n        this.totalRows = rows;\r\n        this.totalCols = cols;\r\n        this.rowNum = rowNum;\r\n        this.colNum = colNum;\r\n\r\n        this.isOpen = true;\r\n        this.isClosed = false;\r\n        this.isWall = false;\r\n        this.isStart = false;\r\n        this.isEnd = false;\r\n        this.isFrontier = false;\r\n        this.isPath = false;\r\n\r\n        this.neighbours = [];\r\n    }\r\n\r\n    // refresh() {\r\n    //     const x = new Node(this.totalRows, this.totalCols, this.rowNum, this.colNum);\r\n    //     x.isOpen = this.isOpen;\r\n    //     x.isWall = this.isWall;\r\n    //     x.isStart = this.isStart;\r\n    //     x.isEnd = this.isEnd;\r\n    //     x.isFrontier = this.isFrontier;\r\n    //     return x;\r\n    // }\r\n\r\n    makeCopy() {\r\n        const nn = new Node(this.totalRows, this.totalCols, this.rowNum, this.colNum);\r\n        nn.isOpen = this.isOpen;\r\n        nn.isClosed = this.isClosed;\r\n        nn.isWall = this.isWall;\r\n        nn.isStart = this.isStart;\r\n        nn.isEnd = this.isEnd;\r\n        nn.isFrontier = this.isFrontier;\r\n        nn.isPath = this.isPath;\r\n        nn.neighbours = this.neighbours;\r\n        return nn;\r\n    }\r\n\r\n    nodeDetails() {\r\n        return {\r\n            \"rowNum\": this.rowNum,\r\n            \"colNum\": this.colNum,\r\n            \"isOpen\": this.isOpen,\r\n            \"isWall\": this.isWall,\r\n            \"isStart\": this.isStart,\r\n            \"isEnd\": this.isEnd,\r\n            \"isFrontier\": this.isFrontier,\r\n        }\r\n    }\r\n\r\n    getX() {\r\n        return this.rowNum;\r\n    }\r\n\r\n    getY() {\r\n        return this.colNum;\r\n    }\r\n\r\n    isEqual(anotherNode) {\r\n        const otherDetails = anotherNode.nodeDetails();\r\n        return this.rowNum === otherDetails.rowNum\r\n        && this.colNum === otherDetails.colNum\r\n        && this.isOpen === otherDetails.isOpen\r\n        && this.isWall === otherDetails.isWall\r\n        && this.isStart === otherDetails.isStart\r\n        && this.isEnd === otherDetails.isEnd\r\n        && this.isFrontier !== otherDetails.isFrontier;\r\n    }\r\n\r\n    toggleOpen() {\r\n        this.isOpen = !this.isOpen;\r\n    }\r\n\r\n    setOpen() {\r\n        this.isOpen = true;\r\n        this.isClosed = false;\r\n    }\r\n\r\n    setClosed() {\r\n        this.isOpen = false;\r\n        this.isClosed = true;\r\n    }\r\n\r\n    setWall(bool) {\r\n        if (bool && (this.isStart || this.isEnd)) return;\r\n        this.isWall = bool;\r\n    }\r\n\r\n    setStart(bool) {\r\n        this.isStart = bool;\r\n    }\r\n\r\n    setEnd(bool) {\r\n        this.isEnd = bool;\r\n    }\r\n\r\n    setFrontier(bool) {\r\n        this.isFrontier = bool;\r\n    }\r\n    \r\n    setPath(bool) {\r\n        this.isPath = bool;\r\n    }\r\n\r\n    reset() {\r\n        this.unpath();\r\n        this.isWall = false;\r\n        this.isStart = false;\r\n        this.isEnd = false;\r\n    }\r\n\r\n    unpath() {\r\n        this.isOpen = true;\r\n        this.isClosed = false;\r\n        this.isFrontier = false;\r\n        this.isPath = false;\r\n    }\r\n\r\n    numPossibleNeighbours() {\r\n        if (this.rowNum === 0 || this.rowNum === this.totalRows - 1) {  // top row or bottom row\r\n            if (this.colNum === 0 || this.colNum === this.totalCols - 1) {  // left most or right most column\r\n                return 2;\r\n            } else return 3;\r\n        } else {  // not top row or bottom row\r\n            if (this.colNum === 0 || this.colNum === this.totalCols - 1) {  // left most or right most column\r\n                return 3;\r\n            } else return 4;\r\n        }\r\n    }\r\n\r\n    generateNeighbours(allNodes, allowDiagonal) {\r\n        this.neighbours = [];\r\n        const isTop = this.rowNum === 0;\r\n        const isBottom = this.rowNum === this.totalRows - 1;\r\n        const isLeft = this.colNum === 0;\r\n        const isRight = this.colNum === this.totalCols - 1;\r\n\r\n        if (!isTop) {\r\n\r\n            if (!allNodes[this.rowNum-1][this.colNum].isWall) \r\n                this.neighbours.push(allNodes[this.rowNum-1][this.colNum]);  // node above it\r\n\r\n            if (allowDiagonal && !isLeft) {\r\n                if (!allNodes[this.rowNum-1][this.colNum-1].isWall) \r\n                    this.neighbours.push(allNodes[this.rowNum-1][this.colNum-1]);  // topleft\r\n            }\r\n\r\n            if (allowDiagonal && !isRight) {\r\n                if (!allNodes[this.rowNum-1][this.colNum+1].isWall) \r\n                    this.neighbours.push(allNodes[this.rowNum-1][this.colNum+1]);  // topright\r\n            }\r\n        }\r\n\r\n        if (!isBottom) {\r\n            if (!allNodes[this.rowNum+1][this.colNum].isWall)\r\n                this.neighbours.push(allNodes[this.rowNum+1][this.colNum]);  // node below it\r\n\r\n            if (allowDiagonal && !isLeft) {\r\n                if (!allNodes[this.rowNum+1][this.colNum-1].isWall)\r\n                this.neighbours.push(allNodes[this.rowNum+1][this.colNum-1]);  // bottomleft\r\n            }\r\n\r\n            if (allowDiagonal && !isRight) {\r\n                if (!allNodes[this.rowNum+1][this.colNum+1].isWall)\r\n                this.neighbours.push(allNodes[this.rowNum+1][this.colNum+1]);  // bottomright\r\n            }\r\n        }\r\n\r\n        if (!isLeft) {\r\n            if (!allNodes[this.rowNum][this.colNum-1].isWall)\r\n                this.neighbours.push(allNodes[this.rowNum][this.colNum-1]);  // node to its left\r\n        }\r\n\r\n        if (!isRight) {\r\n            if (!allNodes[this.rowNum][this.colNum+1].isWall)\r\n                this.neighbours.push(allNodes[this.rowNum][this.colNum+1]);  // node to its right\r\n        }\r\n\r\n        return this.neighbours;\r\n    }\r\n\r\n    genWallNeighbours(allNodes, allowDiagonal) {\r\n        this.wallNeighbours = [];\r\n        const isTop = this.rowNum === 0;\r\n        const isBottom = this.rowNum === this.totalRows - 1;\r\n        const isLeft = this.colNum === 0;\r\n        const isRight = this.colNum === this.totalCols - 1;\r\n\r\n        if (!isTop) {\r\n\r\n            if (allNodes[this.rowNum-1][this.colNum].isWall) \r\n                this.wallNeighbours.push(allNodes[this.rowNum-1][this.colNum]);  // node above it\r\n\r\n            if (allowDiagonal && !isLeft) {\r\n                if (allNodes[this.rowNum-1][this.colNum-1].isWall) \r\n                    this.wallNeighbours.push(allNodes[this.rowNum-1][this.colNum-1]);  // topleft\r\n            }\r\n\r\n            if (allowDiagonal && !isRight) {\r\n                if (allNodes[this.rowNum-1][this.colNum+1].isWall) \r\n                    this.wallNeighbours.push(allNodes[this.rowNum-1][this.colNum+1]);  // topright\r\n            }\r\n        }\r\n\r\n        if (!isBottom) {\r\n            if (allNodes[this.rowNum+1][this.colNum].isWall)\r\n                this.wallNeighbours.push(allNodes[this.rowNum+1][this.colNum]);  // node below it\r\n\r\n            if (allowDiagonal && !isLeft) {\r\n                if (allNodes[this.rowNum+1][this.colNum-1].isWall)\r\n                this.wallNeighbours.push(allNodes[this.rowNum+1][this.colNum-1]);  // bottomleft\r\n            }\r\n\r\n            if (allowDiagonal && !isRight) {\r\n                if (allNodes[this.rowNum+1][this.colNum+1].isWall)\r\n                this.wallNeighbours.push(allNodes[this.rowNum+1][this.colNum+1]);  // bottomright\r\n            }\r\n        }\r\n\r\n        if (!isLeft) {\r\n            if (allNodes[this.rowNum][this.colNum-1].isWall)\r\n                this.wallNeighbours.push(allNodes[this.rowNum][this.colNum-1]);  // node to its left\r\n        }\r\n\r\n        if (!isRight) {\r\n            if (allNodes[this.rowNum][this.colNum+1].isWall)\r\n                this.wallNeighbours.push(allNodes[this.rowNum][this.colNum+1]);  // node to its right\r\n        }\r\n\r\n        return this.wallNeighbours;\r\n    }\r\n\r\n    genMazeNeighbours(allNodes, allowDiagonal) {\r\n        this.mazeNeighbours = [];\r\n        const isTop = this.rowNum === 0 || this.rowNum === 1;\r\n        const isBottom = this.rowNum === this.totalRows - 2 || this.rowNum === this.totalRows - 1;\r\n        const isLeft = this.colNum === 0 || this.colNum === 1;\r\n        const isRight = this.colNum === this.totalCols - 2 || this.colNum === this.totalCols - 1;\r\n\r\n        if (!isTop) {\r\n\r\n            // if (!allNodes[this.rowNum-2][this.colNum].isWall) \r\n                this.mazeNeighbours.push(allNodes[this.rowNum-2][this.colNum]);  // node above it\r\n\r\n            if (allowDiagonal && !isLeft) {\r\n                // if (!allNodes[this.rowNum-2][this.colNum-2].isWall) \r\n                    this.mazeNeighbours.push(allNodes[this.rowNum-2][this.colNum-2]);  // topleft\r\n            }\r\n\r\n            if (allowDiagonal && !isRight) {\r\n                // if (!allNodes[this.rowNum-2][this.colNum+2].isWall) \r\n                    this.mazeNeighbours.push(allNodes[this.rowNum-2][this.colNum+2]);  // topright\r\n            }\r\n        }\r\n\r\n        if (!isBottom) {\r\n            // if (!allNodes[this.rowNum+2][this.colNum].isWall)\r\n                this.mazeNeighbours.push(allNodes[this.rowNum+2][this.colNum]);  // node below it\r\n\r\n            if (allowDiagonal && !isLeft) {\r\n                // if (!allNodes[this.rowNum+2][this.colNum-2].isWall)\r\n                this.mazeNeighbours.push(allNodes[this.rowNum+2][this.colNum-2]);  // bottomleft\r\n            }\r\n\r\n            if (allowDiagonal && !isRight) {\r\n                // if (!allNodes[this.rowNum+2][this.colNum+2].isWall)\r\n                this.mazeNeighbours.push(allNodes[this.rowNum+2][this.colNum+2]);  // bottomright\r\n            }\r\n        }\r\n\r\n        if (!isLeft) {\r\n            // if (!allNodes[this.rowNum][this.colNum-2].isWall)\r\n                this.mazeNeighbours.push(allNodes[this.rowNum][this.colNum-2]);  // node to its left\r\n        }\r\n\r\n        if (!isRight) {\r\n            // if (!allNodes[this.rowNum][this.colNum+2].isWall)\r\n                this.mazeNeighbours.push(allNodes[this.rowNum][this.colNum+2]);  // node to its right\r\n        }\r\n        return this.mazeNeighbours;\r\n    }\r\n\r\n    nodeBetween(allNodes, node2) {\r\n        if (this.rowNum === node2.rowNum) {\r\n            return allNodes[this.rowNum][(this.colNum + node2.colNum)/2];\r\n        } else {\r\n            return allNodes[(this.rowNum + node2.rowNum)/2][this.colNum];\r\n        }\r\n    }\r\n}\r\n\r\nexport default Node;","class Node {\r\n    constructor(key) {\r\n        this.key = key;\r\n        this.next = null;\r\n        this.prev = null;\r\n    }\r\n\r\n    setNext(n) {\r\n        this.next = n;\r\n    }\r\n\r\n    setPrev(n) {\r\n        this.prev = n;\r\n    }\r\n}\r\n\r\nexport default Node;","import Node from \"./Node\";\r\n\r\nclass Queue {\r\n    constructor() {\r\n        this.head = null;\r\n        this.tail = null;\r\n        this.size = 0;\r\n    }\r\n\r\n    enqueue(n) {\r\n        if (this.head === null) {\r\n            this.head = new Node(n);\r\n            this.tail = this.head;\r\n        } else {\r\n            this.tail.setNext(new Node(n));\r\n            this.tail = this.tail.next;\r\n        }\r\n        this.size++;\r\n    }\r\n\r\n    dequeue() {\r\n        const first = this.head;\r\n        this.head = this.head.next;\r\n        this.size--;\r\n        return first.key;\r\n    }\r\n\r\n    length() {\r\n        return this.size;\r\n    }\r\n}\r\n\r\nexport default Queue;","\r\nclass Frame {\r\n    static FRONTIER = 1;\r\n    static CLOSED = 2;\r\n    static PATH = 3;\r\n    static WALL = 4;\r\n    \r\n    constructor(arrNodes, instruction) {\r\n        this.arrNodes = arrNodes;\r\n        this.instruction = instruction;\r\n    }\r\n\r\n    getNodes() {\r\n        return this.arrNodes;\r\n    }\r\n\r\n    updateFrontier() {\r\n        for (const node of this.arrNodes) {\r\n            node.setFrontier(true);\r\n        }\r\n    }\r\n\r\n    updateClosed() {\r\n        for (const node of this.arrNodes) {\r\n            node.setOpen(false);\r\n        }\r\n    }\r\n\r\n    updatePath() {\r\n        for (const node of this.arrNodes) {\r\n            node.setPath(true);\r\n        }\r\n    }\r\n\r\n    updateWall() {\r\n        for (const node of this.arrNodes) {\r\n            node.setWall(true);\r\n        }\r\n    }\r\n\r\n    execute() {\r\n        if (this.instruction === 1) this.updateFrontier();\r\n        if (this.instruction === 2) this.updateClosed();\r\n        if (this.instruction === 3) this.updatePath();\r\n        if (this.instruction === 4) this.updateWall();\r\n    }\r\n}\r\n\r\nexport default Frame;","import Queue from \"./Queue\";\r\nimport FastPriorityQueue from \"fastpriorityqueue\";\r\nimport Frame from \"./Frame\";\r\n\r\n\r\nexport function manhattanDistance(point1, point2) {\r\n    return Math.abs(point1.getX()-point2.getX()) + Math.abs(point1.getY()-point2.getY());\r\n}\r\n\r\n\r\nexport function euclideanDistance(point1, point2) {\r\n    return ((point1.getX() - point2.getX()) ** 2 + (point1.getY() - point2.getY()) ** 2) ** 0.5\r\n}\r\n\r\nexport function bestFirstSearch(startNode, endNode, allNodes, heuristicFunction) {\r\n\r\n    // https://github.com/lemire/FastPriorityQueue.js/\r\n    const q = new FastPriorityQueue((arr1, arr2) => arr1[1] < arr2[1]);\r\n    q.add([startNode, 0]);\r\n\r\n    const cameFrom = new Map();\r\n    cameFrom.set(startNode, null);\r\n\r\n    let found = false;\r\n\r\n    let displayFrames = [];\r\n    let thisFrameFrontierNodes;\r\n\r\n    while (q.size > 0 && !found) {\r\n        const output = q.poll();\r\n        const curNode = output[0];  // since I insert [node, priority]\r\n        if (!curNode.neighbours) continue;\r\n\r\n        thisFrameFrontierNodes = [];  // for visualisation purposes\r\n        for (let i = 0; i < curNode.neighbours.length && !found; i++) {\r\n            let neighbour = curNode.neighbours[i];\r\n            if (neighbour.isEnd) {\r\n                endNode = neighbour;\r\n                cameFrom.set(endNode, curNode);\r\n                found = true;  // end early\r\n            }\r\n            if (!cameFrom.has(neighbour)) {  // has not been evaluated before\r\n                cameFrom.set(neighbour, curNode);  // remember where it came from\r\n                thisFrameFrontierNodes.push(neighbour);  // for visualisation\r\n                const heuristic = heuristicFunction(neighbour, endNode);\r\n                q.add([neighbour, heuristic]);\r\n            }\r\n        }\r\n\r\n        // at this frame, the frontier nodes should light up\r\n        const x = new Frame(thisFrameFrontierNodes, Frame.FRONTIER);\r\n        displayFrames.push(x);\r\n        \r\n        // at this frame, the visited node should be displayed as closed\r\n        const y = new Frame([curNode], Frame.CLOSED)\r\n        displayFrames.push(y);\r\n    }\r\n\r\n    if (!found) return [displayFrames, null];\r\n\r\n    // for visualisation\r\n    const pathFrames = [];\r\n    for (let i = 1; endNode !== null; i++) {\r\n        pathFrames.push(new Frame([endNode], Frame.PATH));\r\n        endNode = cameFrom.get(endNode);\r\n    }\r\n    pathFrames.reverse();\r\n\r\n    // want to return an array of 2 arrays\r\n    // first array is array of Frames showing the visualisation of pathfinding, to be shown first\r\n    // second array is array of Frames showing the final path\r\n    return [displayFrames, pathFrames];\r\n}\r\n\r\n\r\nexport function bfs(startNode, endNode, allNodes, heuristicFunction) {\r\n\r\n    const q = new Queue();\r\n    q.enqueue(startNode);\r\n\r\n    const cameFrom = new Map();\r\n    cameFrom.set(startNode, null);\r\n\r\n    let found = false;\r\n\r\n    let displayFrames = [];\r\n    let thisFrameFrontierNodes;\r\n\r\n    while (q.length() > 0 && !found) {\r\n        const curNode = q.dequeue();\r\n        if (curNode.neighbours === null) continue;\r\n\r\n        thisFrameFrontierNodes = [];  // for visualisation purposes\r\n        for (let i = 0; i < curNode.neighbours.length && !found; i++) {\r\n            let neighbour = curNode.neighbours[i];\r\n            if (neighbour.isEnd) {\r\n                endNode = neighbour;\r\n                cameFrom.set(endNode, curNode);\r\n                found = true;  // end early\r\n            }\r\n            if (!cameFrom.has(neighbour)) {  // has not been evaluated before\r\n                cameFrom.set(neighbour, curNode);  // remember where it came from\r\n                thisFrameFrontierNodes.push(neighbour);  // for visualisation\r\n                q.enqueue(neighbour);\r\n            }\r\n        }\r\n        // at this frame, the frontier nodes should light up\r\n        const x = new Frame(thisFrameFrontierNodes, Frame.FRONTIER);\r\n        displayFrames.push(x);\r\n        \r\n        // at this frame, the visited node should be displayed as closed\r\n        const y = new Frame([curNode], Frame.CLOSED)\r\n        displayFrames.push(y);\r\n    }\r\n\r\n    if (!found) return [displayFrames, null];\r\n\r\n    // for visualisation\r\n    const pathFrames = [];\r\n    for (let i = 1; endNode !== null; i++) {\r\n        pathFrames.push(new Frame([endNode], Frame.PATH));\r\n        endNode = cameFrom.get(endNode);\r\n    }\r\n    pathFrames.reverse();\r\n\r\n    return [displayFrames, pathFrames];\r\n}\r\n\r\nexport function aStar(startNode, endNode, allNodes, heuristicFunction) {\r\n\r\n    // https://github.com/lemire/FastPriorityQueue.js/\r\n    const q = new FastPriorityQueue((arr1, arr2) => arr1[1] < arr2[1]);  // open list\r\n    q.add([startNode, 0]);\r\n\r\n    const nodesInQ = new Set();\r\n    nodesInQ.add(startNode);\r\n\r\n    const cameFrom = new Map();\r\n    cameFrom.set(startNode, null);\r\n\r\n    const gScores = new Map();  // movement cost from startNode\r\n    const fScores = new Map();\r\n    for (let i = 0; i < allNodes.length; i++) {\r\n        for (let j = 0; j < allNodes[i].length; j++) {\r\n            gScores.set(allNodes[i][j], Infinity);\r\n            fScores.set(allNodes[i][j], Infinity);\r\n        }\r\n    }\r\n\r\n    gScores.set(startNode, 0);\r\n    gScores.set(startNode, heuristicFunction(startNode, endNode));\r\n\r\n    let found = false;\r\n\r\n    let displayFrames = [];\r\n    let thisFrameFrontierNodes;\r\n\r\n    while (q.size > 0 && !found) {\r\n        const output = q.poll();\r\n        const curNode = output[0];  // since I insert [node, priority]\r\n        nodesInQ.delete(curNode);\r\n\r\n        if (curNode.neighbours === null) continue;\r\n\r\n        thisFrameFrontierNodes = [];  // for visualisation purposes\r\n\r\n        for (let i = 0; i < curNode.neighbours.length && !found; i++) {\r\n            let neighbour = curNode.neighbours[i];\r\n            if (neighbour.isEnd) {\r\n                endNode = neighbour;\r\n                cameFrom.set(endNode, curNode);\r\n                found = true;  // end early\r\n            }\r\n            \r\n            const tempGScore = gScores.get(curNode) + heuristicFunction(curNode, neighbour);  // weight of edge from current to neighbour\r\n            if (tempGScore < gScores.get(neighbour)) {  // this is a better path\r\n                cameFrom.set(neighbour, curNode);\r\n                gScores.set(neighbour, tempGScore);\r\n                fScores.set(neighbour, tempGScore + heuristicFunction(neighbour, endNode));\r\n                if (!nodesInQ.has(neighbour)) {  // neighbour not in priority queue\r\n                    q.add([neighbour, fScores.get(neighbour)]);\r\n                    nodesInQ.add(neighbour);\r\n                    thisFrameFrontierNodes.push(neighbour);  // for visualisation\r\n                }\r\n            }\r\n        }\r\n\r\n        // at this frame, the frontier nodes should light up\r\n        const x = new Frame(thisFrameFrontierNodes, Frame.FRONTIER);\r\n        displayFrames.push(x);\r\n        \r\n        // at this frame, the visited node should be displayed as closed\r\n        const y = new Frame([curNode], Frame.CLOSED)\r\n        displayFrames.push(y);\r\n    }\r\n\r\n    if (!found) return [displayFrames, null];\r\n\r\n    // for visualisation\r\n    const pathFrames = [];\r\n    for (let i = 1; endNode !== null; i++) {\r\n        pathFrames.push(new Frame([endNode], Frame.PATH));\r\n        endNode = cameFrom.get(endNode);\r\n    }\r\n    pathFrames.reverse();\r\n\r\n    // want to return an array of 2 arrays\r\n    // first array is array of Frames showing the visualisation of pathfinding, to be shown first\r\n    // second array is array of Frames showing the final path\r\n    return [displayFrames, pathFrames];\r\n}","import Node from \"./Node\";\r\n\r\nclass Stack {\r\n    constructor() {\r\n        this.head = null;\r\n        this.tail = null;\r\n        this.size = 0;\r\n    }\r\n\r\n    enqueue(n) {\r\n        const nd = new Node(n);\r\n        if (this.head === null) {\r\n            this.head = nd;\r\n            this.tail = this.head;\r\n        } else {\r\n            nd.setNext(this.head);\r\n            this.head = nd;\r\n        }\r\n        this.size++;\r\n    }\r\n\r\n    dequeue() {\r\n        const first = this.head;\r\n        this.head = this.head.next;\r\n        this.size--;\r\n        return first.key;\r\n    }\r\n\r\n    length() {\r\n        return this.size;\r\n    }\r\n}\r\n\r\nexport default Stack;","class UnionFind {\r\n    \r\n    constructor(arr) {\r\n        this.p = [];\r\n        this.rank = [];\r\n        this.elmToIdx = new Map();\r\n        for (let i = 0; i < arr.length; i++) {\r\n            this.p[i] = i;\r\n            this.rank[i] = 0;\r\n            this.elmToIdx.set(arr[i], i);\r\n        }\r\n    }\r\n\r\n    findSet(elm) {\r\n        return this.findSetHelper(this.elmToIdx.get(elm));\r\n    }\r\n\r\n    findSetHelper(i) {\r\n        if (this.p[i] === i) return i;\r\n        else {\r\n            this.p[i] = this.findSetHelper(this.p[i]);\r\n            return this.p[i]; \r\n        } \r\n    }\r\n\r\n    isSameSet(elm1, elm2) { \r\n        return this.findSet(elm1) === this.findSet(elm2); \r\n    }\r\n\r\n    unionSet(elm1, elm2) { \r\n        if (!this.isSameSet(elm1, elm2)) { \r\n            const x = this.findSet(elm1);\r\n            const y = this.findSet(elm2);\r\n            // rank is used to keep the tree short\r\n            if (this.rank[x] > this.rank[y]) \r\n                this.p[y] = x;\r\n            else { \r\n                this.p[x] = y;\r\n                if (this.rank[x] === this.rank[y]) \r\n                    this.rank[y] = this.rank[y]+1; \r\n            } \r\n        } \r\n    }\r\n}\r\n\r\nexport default UnionFind;","import Frame from \"./Frame\";\r\nimport Stack from \"./Stack\";\r\n// import Queue from \"./Queue\";\r\nimport UnionFind from \"./UnionFind\";\r\n\r\nconst MAX_LOAD = 100;\r\n\r\n\r\nfunction shuffleArray(array) {\r\n    let temp;\r\n    for (let i = array.length - 1; i > 0; i--) {\r\n        // Generate random number\r\n        let j = Math.floor(Math.random() * (i + 1));         \r\n        temp = array[i];\r\n        array[i] = array[j];\r\n        array[j] = temp;\r\n    }\r\n        \r\n    return array;\r\n}\r\n\r\nfunction randBetween(a, b) {\r\n    return Math.floor(Math.random() * (b-a)) + a;\r\n}\r\n\r\nfunction fewRandBetween(a, b, n) {\r\n    const results = [];\r\n    for (let i = 0; i < n; i++) {\r\n        let r = randBetween(a, b);\r\n        while (results.includes(r)) {\r\n            r = randBetween(a, b);\r\n        }\r\n        results.push(r);\r\n    }\r\n    return results;\r\n}\r\n\r\nfunction between(a, b) {\r\n    return Math.floor((b-a)/2);\r\n}\r\n\r\nfunction genAll(nodes) {  // generate all wall neighbours for each node\r\n    for (let i = 0; i < nodes.length; i++) {\r\n        for (let j = 0; j < nodes[0].length; j++) {\r\n            nodes[i][j].genWallNeighbours(nodes, true);\r\n        }\r\n    }\r\n    return nodes;\r\n}\r\n\r\nfunction * genGrid(allNodes) {  // generates the grid, returning the empty walkable nodes\r\n    const borders = [];\r\n    let allWalkable = [];\r\n    const allNodesCopy = allNodes.map(i => i.map(n => n.makeCopy()));\r\n    for (let i = 0; i < allNodesCopy.length; i++) {\r\n        for (let j = 0; j < allNodesCopy[0].length; j++) {\r\n            if (i % 2 === 0 || j % 2 === 0) {\r\n                allNodesCopy[i][j].setWall(true);\r\n                borders.push(allNodesCopy[i][j]);\r\n            } else {\r\n                allNodesCopy[i][j].genMazeNeighbours(allNodesCopy, false);\r\n                allWalkable.push(allNodesCopy[i][j]);\r\n            }\r\n        }\r\n    }\r\n    yield new Frame(borders);\r\n    return allWalkable;\r\n}\r\n\r\nfunction * genAllWalls(allNodes) {  // generates all walls, returning the empty walkable nodes\r\n    const borders = [];\r\n    let allWalkable = [];\r\n    const allNodesCopy = allNodes.map(i => i.map(n => n.makeCopy()));\r\n    for (let i = 0; i < allNodesCopy.length; i++) {\r\n        for (let j = 0; j < allNodesCopy[0].length; j++) {\r\n            allNodesCopy[i][j].setWall(true);\r\n            if (i % 2 !== 0 && j % 2 !== 0) {\r\n                allNodesCopy[i][j].genMazeNeighbours(allNodesCopy, false);\r\n                allWalkable.push(allNodesCopy[i][j]);\r\n            }\r\n            borders.push(allNodesCopy[i][j]);\r\n        }\r\n    }\r\n    yield new Frame(borders);\r\n    return allWalkable;\r\n}\r\n\r\nexport function * aldousBroder(allNodes) {\r\n\r\n    const numRows = allNodes.length;\r\n    const numCols = allNodes[0].length;\r\n\r\n   const genGridFunc = genGrid(allNodes);\r\n   yield genGridFunc.next().value;\r\n   const allWalkable = genGridFunc.next().value;\r\n\r\n    const visited = [];\r\n    for (let i = 0; i < numRows; i++) visited.push(new Array(numCols).fill(false));\r\n\r\n    const totalNumToVisit = allWalkable.length;\r\n    let curNode = allWalkable[randBetween(0, allWalkable.length)];\r\n    let visitedNum = 1;\r\n    let randNeighbour, wall;\r\n\r\n    while (visitedNum !== totalNumToVisit) {\r\n        randNeighbour = curNode.mazeNeighbours[randBetween(0, curNode.mazeNeighbours.length)];\r\n        if (!visited[randNeighbour.rowNum][randNeighbour.colNum]) {\r\n            visited[randNeighbour.rowNum][randNeighbour.colNum] = true;\r\n            visitedNum++;\r\n            wall = curNode.nodeBetween(allNodes, randNeighbour);\r\n            wall.setWall(false);\r\n            yield new Frame([wall]);\r\n        }\r\n        curNode = randNeighbour;\r\n    }\r\n    \r\n}\r\n\r\nexport function * backtracking(allNodes) {\r\n\r\n    const numRows = allNodes.length;\r\n    const numCols = allNodes[0].length;\r\n\r\n    const genGridFunc = genGrid(allNodes);\r\n    yield genGridFunc.next().value;\r\n    const allWalkable = genGridFunc.next().value;\r\n\r\n    const visited = [];\r\n    for (let i = 0; i < numRows; i++) visited.push(new Array(numCols).fill(false));\r\n    \r\n    let stack = new Stack();\r\n    let randNeighbour;\r\n    let curNode = allWalkable[randBetween(0, allWalkable.length)];\r\n    shuffleArray(curNode.mazeNeighbours);\r\n    for (randNeighbour of curNode.mazeNeighbours) {\r\n        stack.enqueue([randNeighbour, curNode]);\r\n    }\r\n\r\n    visited[curNode.rowNum][curNode.colNum] = true;\r\n    let wall;\r\n    while (stack.length() > 0) {\r\n        [randNeighbour, curNode] = stack.dequeue();\r\n        if (visited[randNeighbour.rowNum][randNeighbour.colNum]) continue;\r\n        visited[randNeighbour.rowNum][randNeighbour.colNum] = true;\r\n\r\n        // break wall\r\n        wall = randNeighbour.nodeBetween(allNodes, curNode);\r\n        wall.setWall(false);\r\n        yield new Frame([wall]);\r\n\r\n        curNode = randNeighbour;\r\n        shuffleArray(curNode.mazeNeighbours);\r\n        for (randNeighbour of curNode.mazeNeighbours) {\r\n            stack.enqueue([randNeighbour, curNode]);\r\n        }\r\n    }\r\n}\r\n\r\nexport function * binaryTree(allNodes) {\r\n\r\n    // ======================== grids ========================\r\n \r\n    const genGridFunc = genGrid(allNodes);\r\n    yield genGridFunc.next().value;\r\n    const allWalkable = genGridFunc.next().value;\r\n \r\n     for (let i = 0; i < allWalkable.length; i++) {\r\n         const curNode = allWalkable[i];\r\n         let n;\r\n \r\n         // north or west\r\n         let w = randBetween(1, 3) % 2;\r\n         if (w === 0) {  // north\r\n             if (curNode.rowNum > 1) n = allNodes[curNode.rowNum-1][curNode.colNum];\r\n         }  // west\r\n         if (w === 1) {\r\n             if (curNode.colNum > 1) n = allNodes[curNode.rowNum][curNode.colNum-1]\r\n         }\r\n \r\n         if (n) {\r\n             n.setWall(false);\r\n             yield new Frame([n]);\r\n         }\r\n     }\r\n}\r\n\r\nexport function * growingTree(allNodes) {\r\n\r\n    const numRows = allNodes.length;\r\n    const numCols = allNodes[0].length;\r\n\r\n   // ======================== grids ========================\r\n\r\n    const genGridFunc = genAllWalls(allNodes);\r\n    yield genGridFunc.next().value;\r\n    const allWalkable = genGridFunc.next().value;\r\n\r\n    const visited = [];\r\n    for (let i = 0; i < numRows; i++) visited.push(new Array(numCols).fill(false));\r\n\r\n    let curNode = allWalkable[randBetween(0, allWalkable.length)];\r\n    let listOfCells = [curNode];\r\n\r\n    let noNeighbour;\r\n    let randNeighbour, randNeighbourCopy;\r\n    let wall;\r\n\r\n    visited[curNode.rowNum][curNode.colNum] = true;\r\n    curNode.setWall(false);\r\n    yield new Frame([curNode]);\r\n\r\n    let filterFuncGen = node => x => x!==node;\r\n\r\n    while (true) {\r\n        noNeighbour = true;\r\n        curNode = listOfCells[randBetween(0, listOfCells.length)];\r\n\r\n        shuffleArray(curNode.mazeNeighbours);\r\n        for (randNeighbour of curNode.mazeNeighbours) {\r\n            if (!visited[randNeighbour.rowNum][randNeighbour.colNum]) {\r\n\r\n                visited[randNeighbour.rowNum][randNeighbour.colNum] = true;\r\n\r\n                // remove walls, make paths\r\n                wall = curNode.nodeBetween(allNodes, randNeighbour);\r\n                wall.setWall(false);\r\n\r\n                randNeighbourCopy = randNeighbour.makeCopy();\r\n                randNeighbourCopy.setWall(false);\r\n\r\n                yield new Frame([wall.makeCopy(), randNeighbourCopy.makeCopy()]);\r\n\r\n                // add to list\r\n                listOfCells.push(randNeighbour);\r\n\r\n                noNeighbour = false;\r\n                break;\r\n            }\r\n        }\r\n        if (noNeighbour) {  // remove from array\r\n            listOfCells = listOfCells.filter(filterFuncGen(curNode));\r\n        }\r\n        if (listOfCells.length === 0) {\r\n            break;\r\n        }\r\n    }\r\n}\r\n\r\nexport function * huntAndKill(allNodes) {\r\n\r\n    const numRows = allNodes.length;\r\n    const numCols = allNodes[0].length;\r\n\r\n   // ======================== grids ========================\r\n\r\n    const genGridFunc = genGrid(allNodes);\r\n    yield genGridFunc.next().value;\r\n    const allWalkable = genGridFunc.next().value;\r\n\r\n    const visited = [];\r\n    for (let i = 0; i < numRows; i++) visited.push(new Array(numCols).fill(false));\r\n\r\n    const numNodesToVisit = allWalkable.length;\r\n    let numNodesVisited = 0;\r\n\r\n    let curNode = allWalkable[randBetween(0, allWalkable.length)];\r\n    let noNeighbour;\r\n    let wall;\r\n    let randNeighbour;\r\n\r\n    while (true) {\r\n\r\n        if (!visited[curNode.rowNum][curNode.colNum]) {\r\n            visited[curNode.rowNum][curNode.colNum] = true;\r\n            numNodesVisited++;\r\n        }\r\n\r\n        noNeighbour = true;\r\n        shuffleArray(curNode.mazeNeighbours);\r\n\r\n        for (randNeighbour of curNode.mazeNeighbours) {\r\n            if (!visited[randNeighbour.rowNum][randNeighbour.colNum]) {\r\n                noNeighbour = false;\r\n                \r\n                wall = curNode.nodeBetween(allNodes, randNeighbour);\r\n                wall.setWall(false);\r\n                yield new Frame([wall]);\r\n                \r\n                // this is next curNode\r\n                curNode = randNeighbour;\r\n                break;\r\n            }\r\n        }\r\n\r\n        if (noNeighbour) {\r\n            while (true) {\r\n                curNode = allWalkable[randBetween(0, allWalkable.length)];\r\n                if (visited[curNode.rowNum][curNode.colNum]) break;\r\n            } \r\n        }\r\n\r\n        if (numNodesVisited === numNodesToVisit) break;\r\n    }\r\n}\r\n\r\nexport function * kruskal(allNodes) {\r\n\r\n    const numRows = allNodes.length;\r\n    const numCols = allNodes[0].length;\r\n\r\n   // ======================== grids ========================\r\n\r\n    const genGridFunc = genGrid(allNodes);\r\n    yield genGridFunc.next().value;\r\n    // const allWalkable = genGridFunc.next().value;\r\n\r\n    const visited = [];\r\n    for (let i = 0; i < numRows; i++) visited.push(new Array(numCols).fill(false));\r\n\r\n    // contains a bunch of arrays\r\n    // each array has 3 nodes: a wall, and the 2 nodes it divides\r\n    let allWalls = [];  \r\n    for (let i = 0; i < numRows; i++) {\r\n        for (let j = 0; j < numCols; j++) {\r\n            if (i !== 0 && i !== numRows -1) {\r\n                if (j !== 0 && j !== numCols - 1) {\r\n                    \r\n                    if (i % 2 === 1 && j % 2 === 0) {  // its left and right are paths\r\n                        allWalls.push([allNodes[i][j], allNodes[i][j-1], allNodes[i][j+1]]);\r\n                    } else if (i % 2 === 0 && j % 2 === 1) {  // its up and down are paths\r\n                        allWalls.push([allNodes[i][j], allNodes[i-1][j], allNodes[i+1][j]]);\r\n                    }\r\n\r\n                }\r\n            }\r\n        }\r\n    }\r\n\r\n    const allSpaces = new Set();\r\n    for (let i = 0; i < allWalls.length; i++) {\r\n        allSpaces.add(allWalls[i][1]);  // spaces\r\n        allSpaces.add(allWalls[i][2]);  // spaces\r\n    }\r\n    const UFDS = new UnionFind(Array.from(allSpaces));\r\n    allWalls = shuffleArray(allWalls);\r\n\r\n    let wall, space1, space2;\r\n\r\n    for (let i = 0; i < allWalls.length; i++) {\r\n        [wall, space1, space2] = allWalls[i];\r\n        if (!UFDS.isSameSet(space1, space2)) {\r\n            UFDS.unionSet(space1, space2);\r\n            wall.setWall(false);\r\n            yield new Frame([wall]);\r\n        }\r\n    }\r\n}\r\n\r\nexport function * prim(allNodes) {\r\n\r\n    const numRows = allNodes.length;\r\n    const numCols = allNodes[0].length;\r\n\r\n   // ======================== grids ========================\r\n\r\n    const genGridFunc = genAllWalls(allNodes);\r\n    yield genGridFunc.next().value;\r\n    const allWalkable = genGridFunc.next().value;\r\n\r\n    // contains a bunch of arrays\r\n    // each array has 3 nodes: a wall, and the 2 nodes it divides\r\n    let allWalls = [];  \r\n    for (let i = 0; i < numRows; i++) {\r\n        for (let j = 0; j < numCols; j++) {\r\n            if (i !== 0 && i !== numRows -1) {\r\n                if (j !== 0 && j !== numCols - 1) {\r\n                    \r\n                    if (i % 2 === 1 && j % 2 === 0) {  // its left and right are paths\r\n                        allWalls.push([allNodes[i][j], allNodes[i][j-1], allNodes[i][j+1]]);\r\n                    } else if (i % 2 === 0 && j % 2 === 1) {  // its up and down are paths\r\n                        allWalls.push([allNodes[i][j], allNodes[i-1][j], allNodes[i+1][j]]);\r\n                    }\r\n\r\n                }\r\n            }\r\n        }\r\n    }\r\n\r\n    const visited = [];\r\n    for (let i = 0; i < numRows; i++) visited.push(new Array(numCols).fill(false));\r\n    \r\n    const visitedNodes = new Set();\r\n\r\n    allWalls = shuffleArray(allWalls);\r\n    let [wall, space1, space2] = allWalls.pop();\r\n    space1.setWall(false);\r\n    visitedNodes.add(space1);\r\n    yield new Frame([space1]);\r\n\r\n    while (visitedNodes.size !== allWalkable.length) {\r\n        [wall, space1, space2] = allWalls.pop();\r\n        if (visitedNodes.has(space1) && !visitedNodes.has(space2)) {\r\n            visitedNodes.add(space2);\r\n            space2.setWall(false);\r\n            wall.setWall(false);\r\n            yield new Frame([wall, space2]);\r\n        } else if (!visitedNodes.has(space1) && visitedNodes.has(space2)) {\r\n            visitedNodes.add(space1);\r\n            space1.setWall(false);\r\n            wall.setWall(false);\r\n            yield new Frame([wall, space1]);\r\n        } else {\r\n            allWalls.unshift([wall, space1, space2]);\r\n        }\r\n    }\r\n\r\n  \r\n\r\n}\r\n\r\nexport function * wrongGrowingTree(allNodes) {\r\n\r\n    const numRows = allNodes.length;\r\n    const numCols = allNodes[0].length;\r\n\r\n   // ======================== grids ========================\r\n\r\n    const genGridFunc = genGrid(allNodes);\r\n    yield genGridFunc.next().value;\r\n    const allWalkable = genGridFunc.next().value;\r\n\r\n    const visited = [];\r\n    for (let i = 0; i < numRows; i++) visited.push(new Array(numCols).fill(false));\r\n\r\n    let curNode = allWalkable[randBetween(0, allWalkable.length)];\r\n    let listOfCells = [curNode];\r\n\r\n    let noNeighbour;\r\n    let randNeighbour;\r\n    let wall;\r\n\r\n    let filterFuncGen = node => x => x!==node;\r\n\r\n    while (true) {\r\n        noNeighbour = true;\r\n        curNode = listOfCells[randBetween(0, listOfCells.length)];\r\n        visited[curNode.rowNum][curNode.colNum] = true;\r\n\r\n        shuffleArray(curNode.mazeNeighbours);\r\n        for (randNeighbour of curNode.mazeNeighbours) {\r\n            if (!visited[randNeighbour.rowNum][randNeighbour.colNum]) {\r\n\r\n                wall = curNode.nodeBetween(allNodes, randNeighbour);\r\n                wall.setWall(false);\r\n                yield new Frame([wall]);\r\n\r\n                // add to list\r\n                listOfCells.push(randNeighbour);\r\n\r\n                noNeighbour = false;\r\n                break;\r\n            }\r\n        }\r\n        if (noNeighbour) {  // remove from array\r\n            listOfCells = listOfCells.filter(filterFuncGen(curNode));\r\n        }\r\n        if (listOfCells.length === 0) break;\r\n    }\r\n}\r\n\r\nexport function * randomTree(allNodes) {\r\n\r\n    const numRows = allNodes.length;\r\n    const numCols = allNodes[0].length;\r\n\r\n   // ======================== grids ========================\r\n\r\n   const genGridFunc = genGrid(allNodes);\r\n   yield genGridFunc.next().value;\r\n   const allWalkable = genGridFunc.next().value;\r\n\r\n    for (let i = 0; i < allWalkable.length; i++) {\r\n        const curNode = allWalkable[i];\r\n\r\n        // random number\r\n        let numWallsToRemove = randBetween(1, 4);\r\n        let wallsToRemove = fewRandBetween(0, 4, numWallsToRemove);\r\n        for (const w of wallsToRemove) {\r\n            let n;\r\n            if (w === 0 && curNode.rowNum > 1) n = allNodes[curNode.rowNum-1][curNode.colNum];\r\n            else if (w === 1 && curNode.colNum < numCols-2) n = allNodes[curNode.rowNum][curNode.colNum+1];\r\n            else if (w === 2 && curNode.rowNum < numRows-2) n = allNodes[curNode.rowNum+1][curNode.colNum];\r\n            else if (w === 3 && curNode.colNum > 1) n = allNodes[curNode.rowNum][curNode.colNum-1];\r\n            if (!n) continue;\r\n            n.setWall(false);\r\n            yield new Frame([n]);\r\n        }\r\n    }\r\n}\r\n\r\nexport function * CAMaze(allNodes) {\r\n\r\n    // https://www.conwaylife.com/wiki/OCA:Maze\r\n    //  rulestring B3/S12345)\r\n\r\n    const numRows = allNodes.length;\r\n    const numCols = allNodes[0].length;\r\n\r\n    let allNodesCopy = allNodes.map(i => i.map(n => n.makeCopy()));\r\n\r\n    // ======================== random start? ========================\r\n\r\n    const startFrameNodes = [];\r\n    const lrMid = between(0, numCols - 1);\r\n    const udMid = between(0, numRows - 1);\r\n    const randNum = randBetween(5, 7);\r\n    for (let i = 0; i < randNum; i++) {\r\n        const randRow = randBetween(udMid - 1, udMid + 2);\r\n        const randCol = randBetween(lrMid - 1, lrMid + 2);\r\n        if (allNodesCopy[randRow][randCol].isWall) {\r\n            i --;\r\n            continue;\r\n        }\r\n        allNodesCopy[randRow][randCol].setWall(true);\r\n        startFrameNodes.push(allNodesCopy[randRow][randCol]);\r\n    }\r\n    yield new Frame(startFrameNodes, Frame.WALL);\r\n\r\n    // ======================== CA? ========================\r\n\r\n    let neverChange;\r\n    let curNode;\r\n\r\n    for (let c = 0; c < MAX_LOAD; c++) {\r\n        neverChange = true;\r\n        const oneFrame = [];\r\n        genAll(allNodesCopy);  // regenerate neighbours\r\n        for (let i = 0; i < numRows; i++) {\r\n            for (let j = 0; j < numCols; j++) {\r\n                curNode = allNodesCopy[i][j];\r\n                \r\n                // if dead, and have 3 live neighbours, come alive\r\n                if (!curNode.isWall) {\r\n                    if (curNode.wallNeighbours.length === 3) {\r\n                        curNode.setWall(true);\r\n                        oneFrame.push(curNode);\r\n                        neverChange = false;\r\n                    }\r\n                } else {  // if alive, stay alive if 1-5 neighbours\r\n                    if (curNode.wallNeighbours.length === 0 || curNode.wallNeighbours.length > 5) {\r\n                        curNode.setWall(false);\r\n                        oneFrame.push(curNode);\r\n                        neverChange = false;\r\n                    }\r\n                }\r\n            }\r\n        }\r\n        if (!neverChange) yield new Frame(oneFrame);\r\n        else c = MAX_LOAD;\r\n    }\r\n    return;\r\n}\r\n\r\nexport function * CAMazeCetric(allNodes) {\r\n\r\n    // https://www.conwaylife.com/wiki/OCA:Maze\r\n    //  rulestring B3/S12345)\r\n\r\n    const numRows = allNodes.length;\r\n    const numCols = allNodes[0].length;\r\n\r\n    let allNodesCopy = allNodes.map(i => i.map(n => n.makeCopy()));\r\n\r\n    // ======================== random start? ========================\r\n\r\n    const startFrameNodes = [];\r\n    const lrMid = between(0, numCols - 1);\r\n    const udMid = between(0, numRows - 1);\r\n    const randNum = randBetween(5, 7);\r\n    for (let i = 0; i < randNum; i++) {\r\n        const randRow = randBetween(udMid - 1, udMid + 2);\r\n        const randCol = randBetween(lrMid - 1, lrMid + 2);\r\n        if (allNodesCopy[randRow][randCol].isWall) {\r\n            i --;\r\n            continue;\r\n        }\r\n        allNodesCopy[randRow][randCol].setWall(true);\r\n        startFrameNodes.push(allNodesCopy[randRow][randCol]);\r\n    }\r\n    yield new Frame(startFrameNodes, Frame.WALL);\r\n\r\n    // ======================== CA? ========================\r\n\r\n    let neverChange;\r\n    let curNode;\r\n\r\n    for (let c = 0; c < MAX_LOAD; c++) {\r\n        neverChange = true;\r\n        const oneFrame = [];\r\n        genAll(allNodesCopy);  // regenerate neighbours\r\n        for (let i = 0; i < numRows; i++) {\r\n            for (let j = 0; j < numCols; j++) {\r\n                curNode = allNodesCopy[i][j];\r\n                \r\n                // if dead, and have 3 live neighbours, come alive\r\n                if (!curNode.isWall) {\r\n                    if (curNode.wallNeighbours.length === 3) {\r\n                        curNode.setWall(true);\r\n                        oneFrame.push(curNode);\r\n                        neverChange = false;\r\n                    }\r\n                } else {  // if alive, stay alive if 1-4 neighbours, mazeCentric is 4\r\n                    if (curNode.wallNeighbours.length === 0 || curNode.wallNeighbours.length > 4) {\r\n                        curNode.setWall(false);\r\n                        oneFrame.push(curNode);\r\n                        neverChange = false;\r\n                    }\r\n                }\r\n            }\r\n        }\r\n        if (!neverChange) yield new Frame(oneFrame);\r\n        else c = MAX_LOAD;\r\n    }\r\n    return;\r\n}\r\n\r\nexport function * CATest(allNodes) {\r\n\r\n    // https://www.conwaylife.com/wiki/OCA:Maze\r\n    //  rulestring B3/S12345)\r\n\r\n    const numRows = allNodes.length;\r\n    const numCols = allNodes[0].length;\r\n\r\n    let allNodesCopy = allNodes.map(i => i.map(n => n.makeCopy()));\r\n\r\n    // ======================== random start? ========================\r\n\r\n    const startFrameNodes = [];\r\n    const lrMid = between(0, numCols - 1);\r\n    const udMid = between(0, numRows - 1);\r\n    const randNum = randBetween(5, 7);\r\n    for (let i = 0; i < randNum; i++) {\r\n        const randRow = randBetween(udMid - 1, udMid + 2);\r\n        const randCol = randBetween(lrMid - 1, lrMid + 2);\r\n        if (allNodesCopy[randRow][randCol].isWall) {\r\n            i --;\r\n            continue;\r\n        }\r\n        allNodesCopy[randRow][randCol].setWall(true);\r\n        startFrameNodes.push(allNodesCopy[randRow][randCol]);\r\n    }\r\n    yield new Frame(startFrameNodes, Frame.WALL);\r\n\r\n    // ======================== CA? ========================\r\n\r\n    let neverChange;\r\n    let curNode;\r\n    let oneFrame;\r\n\r\n    // 1, 1-4 interesting\r\n\r\n    for (let c = 0; c < MAX_LOAD; c++) {\r\n        // console.log(c);\r\n        neverChange = true;\r\n        oneFrame = [];\r\n        genAll(allNodesCopy);  // regenerate neighbours\r\n        for (let i = 0; i < numRows; i++) {\r\n            for (let j = 0; j < numCols; j++) {\r\n                curNode = allNodesCopy[i][j];\r\n                \r\n                // if dead, and have 3 live neighbours, come alive\r\n                if (!curNode.isWall) {\r\n                    if (curNode.wallNeighbours.length === 1) {\r\n                        curNode.setWall(true);\r\n                        oneFrame.push(curNode);\r\n                        neverChange = false;\r\n                    }\r\n                } else {  // if alive, stay alive if 1-4 neighbours, mazeCentric is 4, maze is 5\r\n                    if (curNode.wallNeighbours.length === 0 || curNode.wallNeighbours.length > 3) {\r\n                        curNode.setWall(false);\r\n                        oneFrame.push(curNode);\r\n                        neverChange = false;\r\n                    }\r\n                }\r\n            }\r\n        }\r\n        if (!neverChange) yield new Frame(oneFrame);\r\n        else c = MAX_LOAD;\r\n    }\r\n    return;\r\n}\r\n\r\nexport function * fillDeadEnds(allNodes) {\r\n\r\n    const numRows = allNodes.length;\r\n    const numCols = allNodes[0].length;\r\n\r\n    let allNodesCopy = allNodes.map(i => i.map(n => n.makeCopy()));\r\n\r\n    for (let i = 0; i < numRows; i++) {\r\n        for (let j = 0; j < numCols; j++) {\r\n            allNodesCopy[i][j].generateNeighbours(allNodesCopy, false);\r\n        }\r\n    }\r\n\r\n    let changed;\r\n    let thisFrame;\r\n    while (true) {\r\n        for (let i = 0; i < numRows; i++) {\r\n            for (let j = 0; j < numCols; j++) {\r\n                allNodesCopy[i][j].generateNeighbours(allNodesCopy, false);\r\n                allNodesCopy[i][j].genWallNeighbours(allNodesCopy, false);\r\n            }\r\n        }\r\n        changed = false;\r\n        thisFrame = [];\r\n        for (let i = 0; i < numRows; i++) {\r\n            for (let j = 0; j < numCols; j++) {\r\n                const curNode = allNodesCopy[i][j];\r\n                if (curNode.isStart || curNode.isEnd) continue;\r\n                // is not a wall, only 1 neighbour or all neighbours are walls\r\n                if (!curNode.isWall && (curNode.neighbours.length === 1 || curNode.wallNeighbours.length === curNode.numPossibleNeighbours())) {\r\n                    allNodesCopy[i][j].setWall(true);\r\n                    thisFrame.push(allNodesCopy[i][j]);\r\n                    changed = true;\r\n                }\r\n            }\r\n        }\r\n        if (!changed) break;\r\n        yield new Frame(thisFrame, Frame.WALL);\r\n    }\r\n}\r\n\r\n\r\nexport function randCA(allNodes) {\r\n\r\n    const numRows = allNodes.length;\r\n    const numCols = allNodes[0].length;\r\n    const displayFrames = [];\r\n\r\n    let allNodesCopy = allNodes.map(i => i.map(n => n.makeCopy()));\r\n\r\n    function genAll(nodes) {\r\n        for (let i = 0; i < numRows; i++) {\r\n            for (let j = 0; j < numCols; j++) {\r\n                nodes[i][j].genWallNeighbours(nodes, true);\r\n            }\r\n        }\r\n        return nodes;\r\n    }\r\n\r\n    genAll(allNodesCopy);\r\n\r\n    const startFrameNodes = [];\r\n    for (let i = 0; i < 20; i++) {  // 20 random \r\n        const randRow = randBetween(0, numRows);\r\n        const randCol = randBetween(0, numCols);\r\n        allNodesCopy[randRow][randCol].setWall(true);\r\n        startFrameNodes.push(allNodesCopy[randRow][randCol]);\r\n    }\r\n    displayFrames.push(new Frame(startFrameNodes, Frame.WALL));\r\n\r\n    // lets try\r\n    \r\n    for (let c = 0; c < 20; c++) {\r\n        const oneFrame = [];\r\n        genAll(allNodesCopy);  // regenerate neighbours\r\n        for (let i = 0; i < numRows; i++) {\r\n            for (let j = 0; j < numCols; j++) {\r\n                if (allNodesCopy[i][j].wallNeighbours.length >= 1 && allNodesCopy[i][j].wallNeighbours.length <= 2) {\r\n                    if (Math.random() < 0.1) {\r\n                        allNodesCopy[i][j].setWall(true);\r\n                        oneFrame.push(allNodesCopy[i][j]);\r\n                    }\r\n                }\r\n            }\r\n        }\r\n        displayFrames.push(new Frame(oneFrame));\r\n    }\r\n\r\n    return displayFrames;\r\n}\r\n\r\n\r\nexport function randMaze(allNodes) {\r\n\r\n    const numRows = allNodes.length;\r\n    const numCols = allNodes[0].length;\r\n\r\n    let displayFrames = [];\r\n\r\n    function fillRow(rowOrColNum, left, right, up, down) {\r\n        let nodesToChange = [];\r\n        for (let j = left; j < right; j++) {\r\n            // nodesToChange.push(allNodes[rowNum][j]);\r\n            nodesToChange.push(new Frame([allNodes[rowOrColNum][j]], Frame.WALL));\r\n        }\r\n        // remove random one\r\n        // delete nodesToChange[randBetween(left, right)];\r\n        nodesToChange.splice(randBetween(left+1, between(left+1, right-1)), 1);\r\n        nodesToChange.splice(randBetween(between(left+1, right-1), right-1), 1);\r\n        displayFrames = displayFrames.concat(nodesToChange);\r\n        // return nodesToChange.map(n => new Frame([n], Frame.WALL));\r\n        // return new Frame(nodesToChange, Frame.WALL);\r\n    }\r\n\r\n    function fillCol(rowOrColNum, left, right, up, down) {\r\n        const nodesToChange = [];\r\n        for (let i = up; i < down; i++) {\r\n            // nodesToChange.push(allNodes[i][colNum]);\r\n            nodesToChange.push(new Frame([allNodes[i][rowOrColNum]], Frame.WALL));\r\n        }\r\n        // remove random one\r\n        // delete nodesToChange[randBetween(up, down)];\r\n        nodesToChange.splice(randBetween(up+1, between(up+1, down-1)), 1);\r\n        nodesToChange.splice(randBetween(between(up+1, down-1), down-1), 1);\r\n        displayFrames = displayFrames.concat(nodesToChange);\r\n    }\r\n\r\n    function helper(rowOrColNum, l, r, u, d, doRow) {\r\n        // console.log(`${rowOrColNum} ${l} ${r} ${u} ${d}`);\r\n        // if (l+1 === rowOrColNum || rowOrColNum+1 ==) return;\r\n        if (doRow) {\r\n            if (u + 1 >= rowOrColNum || rowOrColNum + 1 >= d) return;\r\n            fillRow(rowOrColNum, l, r, u, d);\r\n            // helper(l + between(l, r), l, r, u, rowOrColNum, !doRow);\r\n            // helper(l + between(l, r), l, r, rowOrColNum+1, d, !doRow);\r\n            const y = between(l, r);\r\n            helper(l + y, l, r, u, rowOrColNum-2, !doRow);\r\n            helper(l + y, l, r, rowOrColNum+2, d, !doRow);\r\n        } else {\r\n            if (l + 1 >= rowOrColNum || rowOrColNum + 1 >= r) return;\r\n            fillCol(rowOrColNum, l, r, u, d);\r\n            const y = between(u, d);\r\n            // helper(u + between(u, d), l, rowOrColNum, u, d, !doRow);\r\n            // helper(u + between(u, d), rowOrColNum+1, r, u, d, !doRow);\r\n            helper(u + y, l, rowOrColNum-2, u, d, !doRow);\r\n            helper(u + y, rowOrColNum+2, r, u, d, !doRow);\r\n        }\r\n    }\r\n\r\n    helper(between(0, numRows), 0, numCols, 0, numRows, true);\r\n\r\n    return displayFrames;\r\n}","import React from \"react\";\n\nimport classes from \"./App.module.css\";\n\nimport Grid from \"./components/Grid\";\nimport Node from \"./components/Node\";\nimport {bfs, bestFirstSearch, aStar} from \"./Algorithms/PathfindingAlgorithms\";\nimport {manhattanDistance, euclideanDistance} from \"./Algorithms/PathfindingAlgorithms\";\nimport {aldousBroder, backtracking, binaryTree, growingTree, wrongGrowingTree, huntAndKill, kruskal, prim,\n  randomTree, CAMaze, CAMazeCetric, fillDeadEnds, CATest} from \"./Algorithms/MazeGeneratingAlgorithms\";\n\nimport Button from \"./components/Button\";\nimport Modal from \"./components/Modal\";\n\n\n\n// function deepCopy(allNodes) {\n//   return allNodes.map(i => i.map(n => n.makeCopy()));\n// }\n\nconst ROWS = 31;\nconst COLUMNS = 61;\n\n// const ROWS = 11;\n// const COLUMNS = 21;\n\n// const ROWS = 91;\n// const COLUMNS = 141;\n\nconst allNodesB = [];\nfor (let i = 0; i < ROWS; i++) {\n    const newRow = [];\n    for (let j = 0; j < COLUMNS; j++) {\n        newRow.push(new Node(ROWS, COLUMNS, i, j));\n    }\n    allNodesB.push(newRow);\n}\n\nfunction App() {\n\n  const [enableInput, setEnableInput] = React.useState(true);\n  const [allNodes, setAllNodes] = React.useState(allNodesB);\n  const [startNode, setStartNode] = React.useState(null);\n  const [endNode, setEndNode] = React.useState(null);\n\n  const [speed, setSpeed] = React.useState(10);  \n  // speed = [1, 10]\n  // 10*speed = [10, 100]\n  // 1000 / 10*speed = [100, 10]\n\n  const DURATION = 100/speed;\n\n  function updateSingleNode(node) {\n    const newAll = allNodes.slice();\n    newAll[node.rowNum][node.colNum] = node;\n    setAllNodes(newAll);\n  }\n\n  function updateFrameNodes(frameOfNodes) {  // takes in a frame of nodes\n    // console.log(frameOfNodes);\n    if (!frameOfNodes) return;\n    // console.log(frameOfNodes.getNodes());\n    if (frameOfNodes.instruction) {\n      frameOfNodes.execute();\n    }\n    const newAll = allNodes.slice();\n    const nodesToUpdate = frameOfNodes.getNodes().slice();\n    for (const n of nodesToUpdate) {\n        newAll[n.rowNum][n.colNum] = n;\n    }\n    setAllNodes(newAll);\n  }\n\n  function clearAll(event) {\n    if (!enableInput) return;\n    const newAll = allNodes.slice();\n    for (let i = 0; i < ROWS; i++) {\n      for (let j = 0; j < COLUMNS; j++) {\n        newAll[i][j].reset();\n      }\n    }\n    setAllNodes(newAll);\n    setStartNode(null);\n    setEndNode(null);\n  }\n\n  function clearWalls() {\n    const newAll = allNodes.slice();\n    for (let i = 0; i < ROWS; i++) {\n      for (let j = 0; j < COLUMNS; j++) {\n        newAll[i][j].setWall(false);\n      }\n    }\n    setAllNodes(newAll);\n  }\n\n  function clearPaths() {\n    const newAll = allNodes.slice();\n    for (let i = 0; i < ROWS; i++) {\n      for (let j = 0; j < COLUMNS; j++) {\n        newAll[i][j].unpath();\n      }\n    }\n    setAllNodes(newAll);\n  }\n\n  function generateNeighbours(diag) {\n    const newNodes = allNodes.slice();\n    for (let i = 0; i < ROWS; i++) {\n      for (let j = 0; j < COLUMNS; j++) {\n        newNodes[i][j].generateNeighbours(newNodes, diag);\n      }\n    }\n    setAllNodes(newNodes);\n  }\n\n  function startPathfinding(event) {\n    if (!enableInput) return;\n    if (startNode && endNode) {\n      clearPaths();\n      generateNeighbours(allowDiagonal);\n      startNode.generateNeighbours(allNodes, allowDiagonal);  // ZZZZZZ\n      const [searchFrames, pathFrames] = selectedAlgo(startNode, endNode, allNodes, selectedHf);\n      visualise(searchFrames, pathFrames);\n    }\n  } \n\n  function visualise(searchFrames, pathFrames) {\n    const numFrames = searchFrames.length;\n    for (let i = 0; i < numFrames; i++) {  // for each frame\n      setTimeout(() => {\n        updateFrameNodes(searchFrames[i]);\n        setEnableInput(false);\n      }, i*DURATION);\n    }\n\n    if (!pathFrames) pathFrames = [];\n\n    for (let i = 0; i < pathFrames.length; i++) {\n      setTimeout(\n      () => {\n        setEnableInput(false); \n        updateFrameNodes(pathFrames[i]);\n      }, \n      (searchFrames.length + i) * DURATION\n      );\n    }\n    setTimeout(\n      () => setEnableInput(true), \n      DURATION * (searchFrames.length + pathFrames.length)\n    );\n  }\n\n  const [selectedAlgoName, setAlgo] = React.useState(\"Best First Search\");\n  const pfNameToFunc = {\n    \"BFS\": bfs,\n    \"Best First Search\": bestFirstSearch,\n    \"A* Search\": aStar\n  }\n  const selectedAlgo = pfNameToFunc[selectedAlgoName];\n  \n  const [selectedHfName, setHf] = React.useState(\"Manhattan Distance\");\n  const hfNameToFunc = {\n    \"Manhattan Distance\": manhattanDistance,\n    \"Euclidean Distance\": euclideanDistance,\n  }\n  const selectedHf = hfNameToFunc[selectedHfName];\n\n  const [allowDiagonal, setAllowDiagonal] = React.useState(false);\n\n  const [showModal, setShowModal] = React.useState(false);\n\n  const genMaze = genFunc => {\n    if (!enableInput) return;\n    clearWalls();\n    clearPaths();\n\n    const displayFrames = genFunc(allNodes);\n    let result = displayFrames.next();\n    let i;\n    for (i = 0; !result.done; i++) {\n      ((r, iter) => \n        setTimeout(() => {\n          updateFrameNodes(r.value);\n          setEnableInput(false);\n        }, iter * DURATION)\n      )(result, i);\n      result = displayFrames.next();\n    }\n    \n    setTimeout(\n      () => {setEnableInput(true);}, \n      DURATION * i\n    );\n  }\n\n  const fillDead = event => {\n    if (!enableInput) return;\n    clearPaths();\n    const displayFrames = fillDeadEnds(allNodes);\n    let result = displayFrames.next();\n    let i;\n    for (i = 0; !result.done; i++) {\n\n      ((r, iter) => \n        setTimeout(() => {\n          updateFrameNodes(r.value);\n          setEnableInput(false);\n        }, iter * DURATION)\n      )(result, i);\n      result = displayFrames.next();\n\n      if (result.done) {\n        setTimeout(\n          () => {setEnableInput(true);}, \n          DURATION * i\n        );\n        return;\n      }\n    }\n  \n  }\n\n  return (\n    <div className={classes.mainDiv}>\n\n      {showModal && <Modal \n        onConfirm={e => setShowModal(false)} \n        title=\"Instructions\" \n        speed={speed} \n        setSpeed={setSpeed} />}\n\n      <div className={classes.topDiv}>\n       \n        <div className={classes.section}>\n          <Button onClick={e => setShowModal(true)} width=\"5vw\" value=\"Instructions\"></Button>\n          <Button onClick={clearAll} value=\"Clear All\" disabled={!enableInput}></Button>\n        </div>\n\n        <div className={classes.section}>\n          {Object.keys(pfNameToFunc).map(name => <Button \n            onClick={() => setAlgo(name)}\n            value={name} \n            key={name}\n            selected={selectedAlgoName===name} />)\n          }\n        </div>\n        \n        <div className={classes.section}>\n          {Object.keys(hfNameToFunc).map(name => <Button \n            onClick={() => setHf(name)}\n            value={name} \n            key={name}\n            selected={selectedHfName===name} />)\n          }\n        </div>\n\n        <div className={classes.section}>\n          <Button \n            onClick={() => setAllowDiagonal(p=>!p)} \n            width=\"7vw\"\n            value=\"Diagonal Travel\"\n            selected={allowDiagonal}/>\n        </div>\n\n        <div className={classes.section}>\n          <Button onClick={startPathfinding} value=\"Start\" disabled={!enableInput}></Button>\n        </div>\n\n      </div>\n\n      <Grid\n        ROWS={ROWS}\n        COLUMNS={COLUMNS}\n\n        enableInput={enableInput}\n\n        allNodes={allNodes}\n        startNode={startNode}\n        setStartNode={setStartNode}\n        endNode={endNode}\n        setEndNode={setEndNode}\n\n        updateNode={updateSingleNode}\n        />\n\n      <div className={classes.topDiv}>\n        <div className={classes.section}>\n          <Button onClick={e => genMaze(aldousBroder)} value=\"Aldous-Broder\" disabled={!enableInput}></Button>\n          <Button onClick={e => genMaze(backtracking)} value=\"Backtracking\" disabled={!enableInput}></Button>\n          <Button onClick={e => genMaze(binaryTree)} value=\"Binary Tree\" disabled={!enableInput}></Button>\n          <Button onClick={e => genMaze(growingTree)} value=\"Growing Tree\" disabled={!enableInput}></Button>\n          <Button onClick={e => genMaze(huntAndKill)} value=\"Hunt and Kill\" disabled={!enableInput}></Button>\n          <Button onClick={e => genMaze(kruskal)} width=\"4vw\" value=\"Kruskal\" disabled={!enableInput}></Button>\n          <Button onClick={e => genMaze(prim)} width=\"4vw\" value=\"Prim\" disabled={!enableInput}></Button>\n        </div>\n\n        <div className={classes.section}>\n          <Button onClick={e => genMaze(randomTree)} value=\"Random Tree\" disabled={!enableInput}></Button>\n          <Button onClick={e => genMaze(wrongGrowingTree)} width=\"7vw\" value=\"Wrong Growing Tree\" disabled={!enableInput}></Button>\n          <Button onClick={e => genMaze(CAMaze)} width=\"5vw\" value=\"Maze (CA)\" disabled={!enableInput}></Button>\n          <Button onClick={e => genMaze(CAMazeCetric)} width=\"8vw\" value=\"MazeCetric (CA)\" disabled={!enableInput}></Button>\n          <Button onClick={e => genMaze(CATest)} width=\"6vw\" value=\"Another CA\" disabled={!enableInput}></Button>\n        </div>\n\n        <div className={classes.section}>\n          <Button onClick={fillDead} value=\"Fill Dead Ends\" disabled={!enableInput}></Button>\n        </div>\n      </div>\n\n\n    </div>\n\n  );\n}\n\nexport default App;\n","import React from \"react\";\r\nimport classes from \"./Button.module.css\";\r\n\r\n\r\nconst Button = props => {\r\n\r\n    const height = props.height ? props.height : \"6vh\";\r\n    const width = props.width ? props.width : \"6vw\";\r\n\r\n    const buttonStyle = {\r\n        \"width\": width,\r\n        \"height\": height,\r\n        \"border\": props.border,\r\n    }\r\n\r\n    return (<div className={\r\n            `${props.hidden ? classes.hidden : \"\"} \r\n            ${classes.buttonClass} \r\n            ${props.selected ? classes.selected : \"\"}\r\n            ${props.disabled ? classes.disabled : \"\"}`}\r\n        style={buttonStyle} \r\n        onClick={props.onClick}>\r\n\r\n            {props.value}\r\n\r\n        </div>);\r\n}\r\n\r\nexport default Button;","import ReactDOM from \"react-dom\";\r\n\r\n// import Button from \"./Button\";\r\nimport classes from \"./Modal.module.css\";\r\n\r\nconst Backdrop = props => {\r\n    return <div className={classes.backdrop} onClick={props.onConfirm}></div>;\r\n};\r\n\r\nconst ModalOverlay = props => {\r\n\r\n    const message = `\r\n    Click on a grid square to set the start and end points. \\n\r\n    Start -> Green \\n\r\n    End -> Red \\n\r\n    Wall -> Black \\n\r\n    To reset a grid square, click on it again.  \\n\r\n    You can also left-click and drag to draw walls quickly, or right-click and drag to delete walls quickly. \r\n    Hint: Zoom out all the way if you want the grids to look different.\r\n    `;\r\n\r\n    const sliderHandler = e => {\r\n        props.setSpeed(e.target.value);\r\n    }\r\n\r\n    return (\r\n        <div className={classes.modal}>\r\n            <header className={classes.header}>\r\n                <h2>\r\n                    {props.title}\r\n                </h2>\r\n            </header>\r\n            <div className={classes.content}>\r\n                {message.split(\"\\n\").map(x => <p key={Math.random()}>{x}</p>)}\r\n                <p>Speed</p>\r\n                <input className={classes.slider} type=\"range\" min=\"1\" max=\"10\" value={props.speed} onInput={sliderHandler} />\r\n                <p onClick={e => window.open(\"https://github.com/leeyiheng12/pathfinding_visualiser\")}>\r\n                    <u>GitHub</u>\r\n                </p>\r\n            </div>\r\n            {/* <footer className={classes.actions}>\r\n                <Button onClick={props.onConfirm}>Ok!</Button>\r\n            </footer> */}\r\n        </div>\r\n    );\r\n};\r\n\r\nconst Modal = props => {\r\n    return (\r\n        <>\r\n            {ReactDOM.createPortal(<Backdrop onConfirm={props.onConfirm} />, document.getElementById(\"backdrop-root\"))}\r\n            {ReactDOM.createPortal(<ModalOverlay \r\n                title={props.title} \r\n                message={props.message} \r\n                onConfirm={props.onConfirm}\r\n                speed={props.speed}\r\n                setSpeed={props.setSpeed} />, document.getElementById(\"overlay-root\"))}\r\n        </>\r\n    );\r\n};\r\n\r\nexport default Modal;","const reportWebVitals = onPerfEntry => {\n  if (onPerfEntry && onPerfEntry instanceof Function) {\n    import('web-vitals').then(({ getCLS, getFID, getFCP, getLCP, getTTFB }) => {\n      getCLS(onPerfEntry);\n      getFID(onPerfEntry);\n      getFCP(onPerfEntry);\n      getLCP(onPerfEntry);\n      getTTFB(onPerfEntry);\n    });\n  }\n};\n\nexport default reportWebVitals;\n","import React from 'react';\nimport ReactDOM from 'react-dom';\nimport './index.css';\nimport App from './App';\nimport reportWebVitals from './reportWebVitals';\n\nReactDOM.render(\n  <React.StrictMode>\n    <App />\n  </React.StrictMode>,\n  document.getElementById('root')\n);\n\n// If you want to start measuring performance in your app, pass a function\n// to log results (for example: reportWebVitals(console.log))\n// or send to an analytics endpoint. Learn more: https://bit.ly/CRA-vitals\nreportWebVitals();\n"],"sourceRoot":""}