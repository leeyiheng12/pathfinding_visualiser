{"version":3,"sources":["App.module.css","components/NodeDisplay.module.css","components/Modal.module.css","components/Button.module.css","components/Grid.module.css","components/NodeDisplay.js","components/Grid.js","components/Node.js","Algorithms/Queue.js","Algorithms/Frame.js","Algorithms/PathfindingAlgorithms.js","Algorithms/MazeGeneratingAlgorithms.js","App.js","components/Button.js","components/Modal.js","reportWebVitals.js","index.js"],"names":["module","exports","NodeDisplay","React","memo","props","node","nodeClass","rightClass","isStart","classes","startStyle","isEnd","endStyle","isWall","wallStyle","isPath","pathStyle","isClosed","closedStyle","isFrontier","frontierStyle","openStyle","className","onClick","event","preventDefault","rowNum","colNum","onMouseEnter","buttons","onDrag","onMouseDown","e","onContextMenu","prevProp","nextProp","isEqual","Grid","allNodes","onDragHandler","enableInput","thisNode","setWall","updateNode","onClickHandler","startNode","setStartNode","setStart","endNode","setEndNode","setEnd","gridClass","map","row","n","Node","rows","cols","this","totalRows","totalCols","isOpen","neighbours","nn","anotherNode","otherDetails","nodeDetails","bool","unpath","allowDiagonal","isTop","isBottom","isLeft","isRight","push","wallNeighbours","key","next","Queue","head","tail","size","setNext","first","Frame","arrNodes","instruction","setFrontier","setOpen","setPath","updateFrontier","updateClosed","updatePath","updateWall","FRONTIER","CLOSED","PATH","WALL","manhattanDistance","point1","point2","Math","abs","getX","getY","euclideanDistance","bestFirstSearch","heuristicFunction","q","FastPriorityQueue","arr1","arr2","add","cameFrom","Map","set","thisFrameFrontierNodes","found","displayFrames","curNode","poll","i","length","neighbour","has","heuristic","x","y","pathFrames","get","reverse","bfs","enqueue","dequeue","aStar","nodesInQ","Set","gScores","fScores","j","Infinity","delete","tempGScore","binaryTree","randomTree","CAMaze","CAMazeCetric","CATest","fillDeadEnds","MAX_LOAD","randBetween","a","b","floor","random","fewRandBetween","results","r","includes","between","genAll","nodes","genWallNeighbours","numRows","numCols","allNodesCopy","makeCopy","borders","allWalkable","w","numWallsToRemove","wallsToRemove","f","startFrameNodes","lrMid","udMid","randNum","randRow","randCol","c","neverChange","oneFrame","generateNeighbours","changed","thisFrame","Button","height","buttonStyle","width","border","hidden","buttonClass","selected","disabled","style","value","Backdrop","backdrop","onConfirm","ModalOverlay","modal","header","title","content","message","split","actions","Modal","ReactDOM","createPortal","document","getElementById","ROWS","COLUMNS","SPEED","allNodesB","newRow","App","useState","setEnableInput","setAllNodes","updateFrameNodes","frameOfNodes","execute","newAll","slice","nodesToUpdate","getNodes","clearPaths","selectedAlgoName","setAlgo","pfNameToFunc","selectedAlgo","selectedHfName","setHf","hfNameToFunc","selectedHf","setAllowDiagonal","showModal","setShowModal","genMaze","genFunc","clearWalls","result","done","iter","setTimeout","mainDiv","topDiv","section","reset","Object","keys","name","p","diag","newNodes","searchFrames","numFrames","visualise","reportWebVitals","onPerfEntry","Function","then","getCLS","getFID","getFCP","getLCP","getTTFB","render","StrictMode"],"mappings":"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","file":"static/js/main.bca58a09.chunk.js","sourcesContent":["// extracted by mini-css-extract-plugin\nmodule.exports = {\"mainDiv\":\"App_mainDiv__1bgfA\",\"topDiv\":\"App_topDiv__3J6E3\",\"section\":\"App_section__1bNIh\"};","// extracted by mini-css-extract-plugin\nmodule.exports = {\"nodeClass\":\"NodeDisplay_nodeClass__NYVm6\",\"openStyle\":\"NodeDisplay_openStyle__26E9r\",\"closedStyle\":\"NodeDisplay_closedStyle__GzlFB\",\"wallStyle\":\"NodeDisplay_wallStyle__30I3g\",\"startStyle\":\"NodeDisplay_startStyle__20Pep\",\"endStyle\":\"NodeDisplay_endStyle__12zuf\",\"frontierStyle\":\"NodeDisplay_frontierStyle__2XGHD\",\"pathStyle\":\"NodeDisplay_pathStyle__3ALCR\"};","// extracted by mini-css-extract-plugin\nmodule.exports = {\"backdrop\":\"Modal_backdrop__221Tr\",\"modal\":\"Modal_modal__2fjcX\",\"header\":\"Modal_header__1i1nh\",\"content\":\"Modal_content__1zRhD\",\"actions\":\"Modal_actions__1IBXM\"};","// extracted by mini-css-extract-plugin\nmodule.exports = {\"buttonClass\":\"Button_buttonClass__B5QHJ\",\"hidden\":\"Button_hidden__2HSR3\",\"selected\":\"Button_selected__13wl8\",\"disabled\":\"Button_disabled__1gUUg\"};","// extracted by mini-css-extract-plugin\nmodule.exports = {\"gridClass\":\"Grid_gridClass__ng9hd\"};","import React from \"react\";\r\nimport classes from \"./NodeDisplay.module.css\";\r\n\r\n\r\nconst NodeDisplay = React.memo(props => {\r\n    \r\n    const node = props.nodeClass;\r\n\r\n    const clickHandler = event => {\r\n        event.preventDefault();\r\n        // alert(`${node.rowNum} ${node.colNum}`);\r\n        props.onClick(event, node.rowNum, node.colNum);\r\n    }\r\n    \r\n    // https://developer.mozilla.org/en-US/docs/Web/API/MouseEvent/buttons\r\n    const moveHandler = event => {\r\n        event.preventDefault();\r\n        if (event.buttons === 1 || event.buttons === 2) {\r\n            props.onDrag(event, node.rowNum, node.colNum);\r\n        }\r\n    }\r\n\r\n    const rightClass = node.isStart \r\n        ? classes.startStyle \r\n        : node.isEnd\r\n            ? classes.endStyle\r\n            : node.isWall\r\n                ? classes.wallStyle\r\n                : node.isPath\r\n                    ? classes.pathStyle\r\n                    : node.isClosed\r\n                        ? classes.closedStyle\r\n                        : node.isFrontier\r\n                            ? classes.frontierStyle\r\n                                : classes.openStyle;\r\n\r\n    return (<div className={`${classes.nodeClass} ${rightClass}`}\r\n        onClick={clickHandler}\r\n        onMouseEnter={moveHandler}\r\n        onMouseDown={e => e.preventDefault()}\r\n        onContextMenu={e => e.preventDefault()}\r\n        >\r\n    </div>);\r\n}, (prevProp, nextProp) => prevProp.nodeClass.isEqual(nextProp.nodeClass));\r\n\r\nexport default NodeDisplay;","import React from \"react\";\r\nimport classes from \"./Grid.module.css\";\r\n\r\nimport NodeDisplay from \"./NodeDisplay\";\r\n\r\nconst Grid = props => {\r\n\r\n    const allNodes = props.allNodes;\r\n    \r\n    const onDragHandler = (event, rowNum, colNum) => {\r\n        // event.preventDefault();\r\n        if (!props.enableInput) return;\r\n        const thisNode = allNodes[rowNum][colNum];\r\n        if (!thisNode.isStart && !thisNode.isEnd) {\r\n            if (event.buttons === 1) {\r\n                thisNode.setWall(true);\r\n                props.updateNode(thisNode);\r\n            } \r\n            if (event.buttons === 2) {\r\n                thisNode.setWall(false);\r\n                props.updateNode(thisNode);\r\n            }\r\n        }\r\n    }\r\n\r\n    const onClickHandler = (event, rowNum, colNum) => {\r\n        if (!props.enableInput) return;\r\n        const thisNode = allNodes[rowNum][colNum];\r\n        if (!props.startNode && !thisNode.isEnd) {  // haven't selected start\r\n            props.setStartNode(thisNode);\r\n            thisNode.setWall(false);\r\n            thisNode.setStart(true);\r\n        } else if (props.startNode && thisNode.isStart) {  // selected start, it's this\r\n            props.setStartNode(null);\r\n            thisNode.setStart(false);\r\n        } else if (!props.endNode) {  // haven't selected end\r\n            props.setEndNode(thisNode);\r\n            thisNode.setWall(false);\r\n            thisNode.setEnd(true);\r\n        } else if (props.endNode && thisNode.isEnd) {  // selected end, it's this\r\n            props.setEndNode(null);\r\n            thisNode.setEnd(false);\r\n        } else {\r\n            thisNode.setWall(!thisNode.isWall);\r\n        }\r\n        props.updateNode(thisNode);\r\n    }\r\n\r\n    return (<>\r\n        <div className={classes.gridClass}>\r\n            {allNodes.map(row => \r\n                row.map(n => <NodeDisplay\r\n                key={2**n.rowNum * 3**n.colNum} \r\n                nodeClass={n}\r\n                onClick={onClickHandler}\r\n                onDrag={onDragHandler} />)\r\n            )}\r\n\r\n        </div>\r\n\r\n    </>);\r\n};\r\n\r\nexport default Grid;","class Node {\r\n    constructor(rows, cols, rowNum, colNum) {  // top left is 0,0\r\n        this.totalRows = rows;\r\n        this.totalCols = cols;\r\n        this.rowNum = rowNum;\r\n        this.colNum = colNum;\r\n\r\n        this.isOpen = true;\r\n        this.isClosed = false;\r\n        this.isWall = false;\r\n        this.isStart = false;\r\n        this.isEnd = false;\r\n        this.isFrontier = false;\r\n        this.isPath = false;\r\n\r\n        this.neighbours = [];\r\n    }\r\n\r\n    // refresh() {\r\n    //     const x = new Node(this.totalRows, this.totalCols, this.rowNum, this.colNum);\r\n    //     x.isOpen = this.isOpen;\r\n    //     x.isWall = this.isWall;\r\n    //     x.isStart = this.isStart;\r\n    //     x.isEnd = this.isEnd;\r\n    //     x.isFrontier = this.isFrontier;\r\n    //     return x;\r\n    // }\r\n\r\n    makeCopy() {\r\n        const nn = new Node(this.totalRows, this.totalCols, this.rowNum, this.colNum);\r\n        nn.isOpen = this.isOpen;\r\n        nn.isClosed = this.isClosed;\r\n        nn.isWall = this.isWall;\r\n        nn.isStart = this.isStart;\r\n        nn.isEnd = this.isEnd;\r\n        nn.isFrontier = this.isFrontier;\r\n        nn.isPath = this.isPath;\r\n        nn.neighbours = this.neighbours;\r\n        return nn;\r\n    }\r\n\r\n    nodeDetails() {\r\n        return {\r\n            \"rowNum\": this.rowNum,\r\n            \"colNum\": this.colNum,\r\n            \"isOpen\": this.isOpen,\r\n            \"isWall\": this.isWall,\r\n            \"isStart\": this.isStart,\r\n            \"isEnd\": this.isEnd,\r\n            \"isFrontier\": this.isFrontier,\r\n        }\r\n    }\r\n\r\n    getX() {\r\n        return this.rowNum;\r\n    }\r\n\r\n    getY() {\r\n        return this.colNum;\r\n    }\r\n\r\n    isEqual(anotherNode) {\r\n        const otherDetails = anotherNode.nodeDetails();\r\n        return this.rowNum === otherDetails.rowNum\r\n        && this.colNum === otherDetails.colNum\r\n        && this.isOpen === otherDetails.isOpen\r\n        && this.isWall === otherDetails.isWall\r\n        && this.isStart === otherDetails.isStart\r\n        && this.isEnd === otherDetails.isEnd\r\n        && this.isFrontier !== otherDetails.isFrontier;\r\n    }\r\n\r\n    toggleOpen() {\r\n        this.isOpen = !this.isOpen;\r\n    }\r\n\r\n    setOpen() {\r\n        this.isOpen = true;\r\n        this.isClosed = false;\r\n    }\r\n\r\n    setClosed() {\r\n        this.isOpen = false;\r\n        this.isClosed = true;\r\n    }\r\n\r\n    setWall(bool) {\r\n        if (bool && (this.isStart || this.isEnd)) return;\r\n        this.isWall = bool;\r\n    }\r\n\r\n    setStart(bool) {\r\n        this.isStart = bool;\r\n    }\r\n\r\n    setEnd(bool) {\r\n        this.isEnd = bool;\r\n    }\r\n\r\n    setFrontier(bool) {\r\n        this.isFrontier = bool;\r\n    }\r\n    \r\n    setPath(bool) {\r\n        this.isPath = bool;\r\n    }\r\n\r\n    reset() {\r\n        this.unpath();\r\n        this.isWall = false;\r\n        this.isStart = false;\r\n        this.isEnd = false;\r\n    }\r\n\r\n    unpath() {\r\n        this.isOpen = true;\r\n        this.isClosed = false;\r\n        this.isFrontier = false;\r\n        this.isPath = false;\r\n    }\r\n\r\n    generateNeighbours(allNodes, allowDiagonal) {\r\n        this.neighbours = [];\r\n        const isTop = this.rowNum === 0;\r\n        const isBottom = this.rowNum === this.totalRows - 1;\r\n        const isLeft = this.colNum === 0;\r\n        const isRight = this.colNum === this.totalCols - 1;\r\n\r\n        if (!isTop) {\r\n\r\n            if (!allNodes[this.rowNum-1][this.colNum].isWall) \r\n                this.neighbours.push(allNodes[this.rowNum-1][this.colNum]);  // node above it\r\n\r\n            if (allowDiagonal && !isLeft) {\r\n                if (!allNodes[this.rowNum-1][this.colNum-1].isWall) \r\n                    this.neighbours.push(allNodes[this.rowNum-1][this.colNum-1]);  // topleft\r\n            }\r\n\r\n            if (allowDiagonal && !isRight) {\r\n                if (!allNodes[this.rowNum-1][this.colNum+1].isWall) \r\n                    this.neighbours.push(allNodes[this.rowNum-1][this.colNum+1]);  // topright\r\n            }\r\n        }\r\n\r\n        if (!isBottom) {\r\n            if (!allNodes[this.rowNum+1][this.colNum].isWall)\r\n                this.neighbours.push(allNodes[this.rowNum+1][this.colNum]);  // node below it\r\n\r\n            if (allowDiagonal && !isLeft) {\r\n                if (!allNodes[this.rowNum+1][this.colNum-1].isWall)\r\n                this.neighbours.push(allNodes[this.rowNum+1][this.colNum-1]);  // bottomleft\r\n            }\r\n\r\n            if (allowDiagonal && !isRight) {\r\n                if (!allNodes[this.rowNum+1][this.colNum+1].isWall)\r\n                this.neighbours.push(allNodes[this.rowNum+1][this.colNum+1]);  // bottomright\r\n            }\r\n        }\r\n\r\n        if (!isLeft) {\r\n            if (!allNodes[this.rowNum][this.colNum-1].isWall)\r\n                this.neighbours.push(allNodes[this.rowNum][this.colNum-1]);  // node to its left\r\n        }\r\n\r\n        if (!isRight) {\r\n            if (!allNodes[this.rowNum][this.colNum+1].isWall)\r\n                this.neighbours.push(allNodes[this.rowNum][this.colNum+1]);  // node to its right\r\n        }\r\n    }\r\n\r\n    genWallNeighbours(allNodes, allowDiagonal) {\r\n        this.wallNeighbours = [];\r\n        const isTop = this.rowNum === 0;\r\n        const isBottom = this.rowNum === this.totalRows - 1;\r\n        const isLeft = this.colNum === 0;\r\n        const isRight = this.colNum === this.totalCols - 1;\r\n\r\n        if (!isTop) {\r\n\r\n            if (allNodes[this.rowNum-1][this.colNum].isWall) \r\n                this.wallNeighbours.push(allNodes[this.rowNum-1][this.colNum]);  // node above it\r\n\r\n            if (allowDiagonal && !isLeft) {\r\n                if (allNodes[this.rowNum-1][this.colNum-1].isWall) \r\n                    this.wallNeighbours.push(allNodes[this.rowNum-1][this.colNum-1]);  // topleft\r\n            }\r\n\r\n            if (allowDiagonal && !isRight) {\r\n                if (allNodes[this.rowNum-1][this.colNum+1].isWall) \r\n                    this.wallNeighbours.push(allNodes[this.rowNum-1][this.colNum+1]);  // topright\r\n            }\r\n        }\r\n\r\n        if (!isBottom) {\r\n            if (allNodes[this.rowNum+1][this.colNum].isWall)\r\n                this.wallNeighbours.push(allNodes[this.rowNum+1][this.colNum]);  // node below it\r\n\r\n            if (allowDiagonal && !isLeft) {\r\n                if (allNodes[this.rowNum+1][this.colNum-1].isWall)\r\n                this.wallNeighbours.push(allNodes[this.rowNum+1][this.colNum-1]);  // bottomleft\r\n            }\r\n\r\n            if (allowDiagonal && !isRight) {\r\n                if (allNodes[this.rowNum+1][this.colNum+1].isWall)\r\n                this.wallNeighbours.push(allNodes[this.rowNum+1][this.colNum+1]);  // bottomright\r\n            }\r\n        }\r\n\r\n        if (!isLeft) {\r\n            if (allNodes[this.rowNum][this.colNum-1].isWall)\r\n                this.wallNeighbours.push(allNodes[this.rowNum][this.colNum-1]);  // node to its left\r\n        }\r\n\r\n        if (!isRight) {\r\n            if (allNodes[this.rowNum][this.colNum+1].isWall)\r\n                this.wallNeighbours.push(allNodes[this.rowNum][this.colNum+1]);  // node to its right\r\n        }\r\n    }\r\n}\r\n\r\nexport default Node;","class Node {\r\n    constructor(key) {\r\n        this.key = key;\r\n        this.next = null;\r\n    }\r\n\r\n    setNext(n) {\r\n        this.next = n;\r\n    }\r\n}\r\n\r\nclass Queue {\r\n    constructor() {\r\n        this.head = null;\r\n        this.tail = null;\r\n        this.size = 0;\r\n    }\r\n\r\n    enqueue(n) {\r\n        if (this.head === null) {\r\n            this.head = new Node(n);\r\n            this.tail = this.head;\r\n        } else {\r\n            this.tail.setNext(new Node(n));\r\n            this.tail = this.tail.next;\r\n        }\r\n        this.size++;\r\n    }\r\n\r\n    dequeue() {\r\n        const first = this.head;\r\n        this.head = this.head.next;\r\n        this.size--;\r\n        return first.key;\r\n    }\r\n\r\n    length() {\r\n        return this.size;\r\n    }\r\n}\r\n\r\nexport default Queue;","\r\nclass Frame {\r\n    static FRONTIER = 1;\r\n    static CLOSED = 2;\r\n    static PATH = 3;\r\n    static WALL = 4;\r\n    \r\n    constructor(arrNodes, instruction) {\r\n        this.arrNodes = arrNodes;\r\n        this.instruction = instruction;\r\n    }\r\n\r\n    getNodes() {\r\n        return this.arrNodes;\r\n    }\r\n\r\n    updateFrontier() {\r\n        for (const node of this.arrNodes) {\r\n            node.setFrontier(true);\r\n        }\r\n    }\r\n\r\n    updateClosed() {\r\n        for (const node of this.arrNodes) {\r\n            node.setOpen(false);\r\n        }\r\n    }\r\n\r\n    updatePath() {\r\n        for (const node of this.arrNodes) {\r\n            node.setPath(true);\r\n        }\r\n    }\r\n\r\n    updateWall() {\r\n        for (const node of this.arrNodes) {\r\n            node.setWall(true);\r\n        }\r\n    }\r\n\r\n    execute() {\r\n        if (this.instruction === 1) this.updateFrontier();\r\n        if (this.instruction === 2) this.updateClosed();\r\n        if (this.instruction === 3) this.updatePath();\r\n        if (this.instruction === 4) this.updateWall();\r\n    }\r\n}\r\n\r\nexport default Frame;","import Queue from \"./Queue\";\r\nimport FastPriorityQueue from \"fastpriorityqueue\";\r\nimport Frame from \"./Frame\";\r\n\r\n\r\nexport function manhattanDistance(point1, point2) {\r\n    return Math.abs(point1.getX()-point2.getX()) + Math.abs(point1.getY()-point2.getY());\r\n}\r\n\r\n\r\nexport function euclideanDistance(point1, point2) {\r\n    return ((point1.getX() - point2.getX()) ** 2 + (point1.getY() - point2.getY()) ** 2) ** 0.5\r\n}\r\n\r\nexport function bestFirstSearch(startNode, endNode, allNodes, heuristicFunction) {\r\n\r\n    // https://github.com/lemire/FastPriorityQueue.js/\r\n    const q = new FastPriorityQueue((arr1, arr2) => arr1[1] < arr2[1]);\r\n    q.add([startNode, 0]);\r\n\r\n    const cameFrom = new Map();\r\n    cameFrom.set(startNode, null);\r\n\r\n    let found = false;\r\n\r\n    let displayFrames = [];\r\n    let thisFrameFrontierNodes;\r\n\r\n    while (q.size > 0 && !found) {\r\n        const output = q.poll();\r\n        const curNode = output[0];  // since I insert [node, priority]\r\n        if (!curNode.neighbours) continue;\r\n\r\n        thisFrameFrontierNodes = [];  // for visualisation purposes\r\n        for (let i = 0; i < curNode.neighbours.length && !found; i++) {\r\n            let neighbour = curNode.neighbours[i];\r\n            if (neighbour.isEnd) {\r\n                endNode = neighbour;\r\n                cameFrom.set(endNode, curNode);\r\n                found = true;  // end early\r\n            }\r\n            if (!cameFrom.has(neighbour)) {  // has not been evaluated before\r\n                cameFrom.set(neighbour, curNode);  // remember where it came from\r\n                thisFrameFrontierNodes.push(neighbour);  // for visualisation\r\n                const heuristic = heuristicFunction(neighbour, endNode);\r\n                q.add([neighbour, heuristic]);\r\n            }\r\n        }\r\n\r\n        // at this frame, the frontier nodes should light up\r\n        const x = new Frame(thisFrameFrontierNodes, Frame.FRONTIER);\r\n        displayFrames.push(x);\r\n        \r\n        // at this frame, the visited node should be displayed as closed\r\n        const y = new Frame([curNode], Frame.CLOSED)\r\n        displayFrames.push(y);\r\n    }\r\n\r\n    if (!found) return [displayFrames, null];\r\n\r\n    // for visualisation\r\n    const pathFrames = [];\r\n    for (let i = 1; endNode !== null; i++) {\r\n        pathFrames.push(new Frame([endNode], Frame.PATH));\r\n        endNode = cameFrom.get(endNode);\r\n    }\r\n    pathFrames.reverse();\r\n\r\n    // want to return an array of 2 arrays\r\n    // first array is array of Frames showing the visualisation of pathfinding, to be shown first\r\n    // second array is array of Frames showing the final path\r\n    return [displayFrames, pathFrames];\r\n}\r\n\r\n\r\nexport function bfs(startNode, endNode, allNodes, heuristicFunction) {\r\n\r\n    const q = new Queue();\r\n    q.enqueue(startNode);\r\n\r\n    const cameFrom = new Map();\r\n    cameFrom.set(startNode, null);\r\n\r\n    let found = false;\r\n\r\n    let displayFrames = [];\r\n    let thisFrameFrontierNodes;\r\n\r\n    while (q.size > 0 && !found) {\r\n        const curNode = q.dequeue();\r\n        if (curNode.neighbours === null) continue;\r\n\r\n        thisFrameFrontierNodes = [];  // for visualisation purposes\r\n        for (let i = 0; i < curNode.neighbours.length && !found; i++) {\r\n            let neighbour = curNode.neighbours[i];\r\n            if (neighbour.isEnd) {\r\n                endNode = neighbour;\r\n                cameFrom.set(endNode, curNode);\r\n                found = true;  // end early\r\n            }\r\n            if (!cameFrom.has(neighbour)) {  // has not been evaluated before\r\n                cameFrom.set(neighbour, curNode);  // remember where it came from\r\n                thisFrameFrontierNodes.push(neighbour);  // for visualisation\r\n                q.enqueue(neighbour);\r\n            }\r\n        }\r\n        // at this frame, the frontier nodes should light up\r\n        const x = new Frame(thisFrameFrontierNodes, Frame.FRONTIER);\r\n        displayFrames.push(x);\r\n        \r\n        // at this frame, the visited node should be displayed as closed\r\n        const y = new Frame([curNode], Frame.CLOSED)\r\n        displayFrames.push(y);\r\n    }\r\n\r\n    if (!found) return [displayFrames, null];\r\n\r\n    // for visualisation\r\n    const pathFrames = [];\r\n    for (let i = 1; endNode !== null; i++) {\r\n        pathFrames.push(new Frame([endNode], Frame.PATH));\r\n        endNode = cameFrom.get(endNode);\r\n    }\r\n    pathFrames.reverse();\r\n\r\n    return [displayFrames, pathFrames];\r\n}\r\n\r\nexport function aStar(startNode, endNode, allNodes, heuristicFunction) {\r\n\r\n    // https://github.com/lemire/FastPriorityQueue.js/\r\n    const q = new FastPriorityQueue((arr1, arr2) => arr1[1] < arr2[1]);  // open list\r\n    q.add([startNode, 0]);\r\n\r\n    const nodesInQ = new Set();\r\n    nodesInQ.add(startNode);\r\n\r\n    const cameFrom = new Map();\r\n    cameFrom.set(startNode, null);\r\n\r\n    const gScores = new Map();  // movement cost from startNode\r\n    const fScores = new Map();\r\n    for (let i = 0; i < allNodes.length; i++) {\r\n        for (let j = 0; j < allNodes[i].length; j++) {\r\n            gScores.set(allNodes[i][j], Infinity);\r\n            fScores.set(allNodes[i][j], Infinity);\r\n        }\r\n    }\r\n\r\n    gScores.set(startNode, 0);\r\n    gScores.set(startNode, heuristicFunction(startNode, endNode));\r\n\r\n    let found = false;\r\n\r\n    let displayFrames = [];\r\n    let thisFrameFrontierNodes;\r\n\r\n    while (q.size > 0 && !found) {\r\n        const output = q.poll();\r\n        const curNode = output[0];  // since I insert [node, priority]\r\n        nodesInQ.delete(curNode);\r\n\r\n        if (curNode.neighbours === null) continue;\r\n\r\n        thisFrameFrontierNodes = [];  // for visualisation purposes\r\n\r\n        for (let i = 0; i < curNode.neighbours.length && !found; i++) {\r\n            let neighbour = curNode.neighbours[i];\r\n            if (neighbour.isEnd) {\r\n                endNode = neighbour;\r\n                cameFrom.set(endNode, curNode);\r\n                found = true;  // end early\r\n            }\r\n            \r\n            const tempGScore = gScores.get(curNode) + heuristicFunction(curNode, neighbour);  // weight of edge from current to neighbour\r\n            if (tempGScore < gScores.get(neighbour)) {  // this is a better path\r\n                cameFrom.set(neighbour, curNode);\r\n                gScores.set(neighbour, tempGScore);\r\n                fScores.set(neighbour, tempGScore + heuristicFunction(neighbour, endNode));\r\n                if (!nodesInQ.has(neighbour)) {  // neighbour not in priority queue\r\n                    q.add([neighbour, fScores.get(neighbour)]);\r\n                    nodesInQ.add(neighbour);\r\n                    thisFrameFrontierNodes.push(neighbour);  // for visualisation\r\n                }\r\n            }\r\n        }\r\n\r\n        // at this frame, the frontier nodes should light up\r\n        const x = new Frame(thisFrameFrontierNodes, Frame.FRONTIER);\r\n        displayFrames.push(x);\r\n        \r\n        // at this frame, the visited node should be displayed as closed\r\n        const y = new Frame([curNode], Frame.CLOSED)\r\n        displayFrames.push(y);\r\n    }\r\n\r\n    if (!found) return [displayFrames, null];\r\n\r\n    // for visualisation\r\n    const pathFrames = [];\r\n    for (let i = 1; endNode !== null; i++) {\r\n        pathFrames.push(new Frame([endNode], Frame.PATH));\r\n        endNode = cameFrom.get(endNode);\r\n    }\r\n    pathFrames.reverse();\r\n\r\n    // want to return an array of 2 arrays\r\n    // first array is array of Frames showing the visualisation of pathfinding, to be shown first\r\n    // second array is array of Frames showing the final path\r\n    return [displayFrames, pathFrames];\r\n}","import Frame from \"./Frame\";\r\n\r\nconst MAX_LOAD = 100;\r\n\r\nfunction randBetween(a, b) {\r\n    return Math.floor(Math.random() * (b-a)) + a;\r\n}\r\n\r\nfunction fewRandBetween(a, b, n) {\r\n    const results = [];\r\n    for (let i = 0; i < n; i++) {\r\n        let r = randBetween(a, b);\r\n        while (results.includes(r)) {\r\n            r = randBetween(a, b);\r\n        }\r\n        results.push(r);\r\n    }\r\n    return results;\r\n}\r\n\r\nfunction between(a, b) {\r\n    return Math.floor((b-a)/2);\r\n}\r\n\r\nfunction genAll(nodes) {\r\n    for (let i = 0; i < nodes.length; i++) {\r\n        for (let j = 0; j < nodes[0].length; j++) {\r\n            nodes[i][j].genWallNeighbours(nodes, true);\r\n        }\r\n    }\r\n    return nodes;\r\n}\r\n\r\nexport function * binaryTree(allNodes) {\r\n\r\n    const numRows = allNodes.length;\r\n    const numCols = allNodes[0].length;\r\n\r\n    let allNodesCopy = allNodes.map(i => i.map(n => n.makeCopy()));\r\n\r\n   // ======================== grids ========================\r\n\r\n    const borders = [];\r\n    const allWalkable = [];\r\n    for (let i = 0; i < numRows; i++) {\r\n        for (let j = 0; j < numCols; j++) {\r\n            if (i % 2 === 1 || j % 2 === 1) {\r\n                allNodesCopy[i][j].setWall(true);\r\n                borders.push(allNodesCopy[i][j]);\r\n            } else {\r\n                allWalkable.push(allNodesCopy[i][j]);\r\n            }\r\n        }\r\n    }\r\n    yield new Frame(borders);\r\n\r\n    for (let i = 0; i < allWalkable.length; i++) {\r\n        const curNode = allWalkable[i];\r\n        let n;\r\n\r\n        // north or west\r\n        let w = randBetween(1, 3) % 2;\r\n        if (w === 0) {  // north\r\n            if (curNode.rowNum > 0) n = allNodesCopy[curNode.rowNum-1][curNode.colNum];\r\n        }  // west\r\n        if (w === 1) {\r\n            if (curNode.colNum > 0) n = allNodesCopy[curNode.rowNum][curNode.colNum-1]\r\n        }\r\n\r\n        if (n) {\r\n            const nn = n.makeCopy();\r\n            nn.setWall(false);\r\n            yield new Frame([nn]);\r\n        }\r\n    }\r\n}\r\n\r\nexport function * randomTree(allNodes) {\r\n\r\n    const numRows = allNodes.length;\r\n    const numCols = allNodes[0].length;\r\n\r\n    let allNodesCopy = allNodes.map(i => i.map(n => n.makeCopy()));\r\n\r\n   // ======================== grids ========================\r\n\r\n    const borders = [];\r\n    const allWalkable = [];\r\n    // let walkable;\r\n    for (let i = 0; i < numRows; i++) {\r\n        // walkable = [];\r\n        for (let j = 0; j < numCols; j++) {\r\n            if (i % 2 === 1 || j % 2 === 1) {\r\n                borders.push(allNodesCopy[i][j]);\r\n            } else {\r\n                allWalkable.push(allNodesCopy[i][j]);\r\n            }\r\n        }\r\n    }\r\n    yield new Frame(borders, Frame.WALL);\r\n\r\n    for (let i = 0; i < allWalkable.length; i++) {\r\n        const curNode = allWalkable[i];\r\n\r\n        // random number\r\n        let numWallsToRemove = randBetween(1, 4);\r\n        let wallsToRemove = fewRandBetween(0, 4, numWallsToRemove);\r\n        for (const w of wallsToRemove) {\r\n            let n;\r\n            if (w === 0 && curNode.rowNum > 0) n = allNodesCopy[curNode.rowNum-1][curNode.colNum];\r\n            if (w === 1 && curNode.colNum < numCols-1) n = allNodesCopy[curNode.rowNum][curNode.colNum+1];\r\n            if (w === 2 && curNode.rowNum < numRows-1) n = allNodesCopy[curNode.rowNum+1][curNode.colNum];\r\n            if (w === 3 && curNode.colNum > 0) n = allNodesCopy[curNode.rowNum][curNode.colNum-1];\r\n            if (!n) continue;\r\n            const nn = n.makeCopy();\r\n            nn.setWall(false);\r\n            yield new Frame([nn]);\r\n        }\r\n    }\r\n}\r\n\r\nexport function * CAMaze(allNodes) {\r\n\r\n    // https://www.conwaylife.com/wiki/OCA:Maze\r\n    //  rulestring B3/S12345)\r\n\r\n    const numRows = allNodes.length;\r\n    const numCols = allNodes[0].length;\r\n\r\n    let allNodesCopy = allNodes.map(i => i.map(n => n.makeCopy()));\r\n\r\n    // ======================== random start? ========================\r\n\r\n    const startFrameNodes = [];\r\n    const lrMid = between(0, numCols - 1);\r\n    const udMid = between(0, numRows - 1);\r\n    const randNum = randBetween(5, 7);\r\n    for (let i = 0; i < randNum; i++) {\r\n        const randRow = randBetween(udMid - 1, udMid + 2);\r\n        const randCol = randBetween(lrMid - 1, lrMid + 2);\r\n        if (allNodesCopy[randRow][randCol].isWall) {\r\n            i --;\r\n            continue;\r\n        }\r\n        allNodesCopy[randRow][randCol].setWall(true);\r\n        startFrameNodes.push(allNodesCopy[randRow][randCol]);\r\n    }\r\n    yield new Frame(startFrameNodes, Frame.WALL);\r\n\r\n    // ======================== CA? ========================\r\n\r\n    let neverChange;\r\n    let curNode;\r\n\r\n    for (let c = 0; c < MAX_LOAD; c++) {\r\n        neverChange = true;\r\n        const oneFrame = [];\r\n        genAll(allNodesCopy);  // regenerate neighbours\r\n        for (let i = 0; i < numRows; i++) {\r\n            for (let j = 0; j < numCols; j++) {\r\n                curNode = allNodesCopy[i][j];\r\n                \r\n                // if dead, and have 3 live neighbours, come alive\r\n                if (!curNode.isWall) {\r\n                    if (curNode.wallNeighbours.length === 3) {\r\n                        curNode.setWall(true);\r\n                        oneFrame.push(curNode);\r\n                        neverChange = false;\r\n                    }\r\n                } else {  // if alive, stay alive if 1-5 neighbours\r\n                    if (curNode.wallNeighbours.length === 0 || curNode.wallNeighbours.length > 5) {\r\n                        curNode.setWall(false);\r\n                        oneFrame.push(curNode);\r\n                        neverChange = false;\r\n                    }\r\n                }\r\n            }\r\n        }\r\n        if (!neverChange) yield new Frame(oneFrame);\r\n        else c = MAX_LOAD;\r\n    }\r\n    return;\r\n}\r\n\r\nexport function * CAMazeCetric(allNodes) {\r\n\r\n    // https://www.conwaylife.com/wiki/OCA:Maze\r\n    //  rulestring B3/S12345)\r\n\r\n    const numRows = allNodes.length;\r\n    const numCols = allNodes[0].length;\r\n\r\n    let allNodesCopy = allNodes.map(i => i.map(n => n.makeCopy()));\r\n\r\n    // ======================== random start? ========================\r\n\r\n    const startFrameNodes = [];\r\n    const lrMid = between(0, numCols - 1);\r\n    const udMid = between(0, numRows - 1);\r\n    const randNum = randBetween(5, 7);\r\n    for (let i = 0; i < randNum; i++) {\r\n        const randRow = randBetween(udMid - 1, udMid + 2);\r\n        const randCol = randBetween(lrMid - 1, lrMid + 2);\r\n        if (allNodesCopy[randRow][randCol].isWall) {\r\n            i --;\r\n            continue;\r\n        }\r\n        allNodesCopy[randRow][randCol].setWall(true);\r\n        startFrameNodes.push(allNodesCopy[randRow][randCol]);\r\n    }\r\n    yield new Frame(startFrameNodes, Frame.WALL);\r\n\r\n    // ======================== CA? ========================\r\n\r\n    let neverChange;\r\n    let curNode;\r\n\r\n    for (let c = 0; c < MAX_LOAD; c++) {\r\n        neverChange = true;\r\n        const oneFrame = [];\r\n        genAll(allNodesCopy);  // regenerate neighbours\r\n        for (let i = 0; i < numRows; i++) {\r\n            for (let j = 0; j < numCols; j++) {\r\n                curNode = allNodesCopy[i][j];\r\n                \r\n                // if dead, and have 3 live neighbours, come alive\r\n                if (!curNode.isWall) {\r\n                    if (curNode.wallNeighbours.length === 3) {\r\n                        curNode.setWall(true);\r\n                        oneFrame.push(curNode);\r\n                        neverChange = false;\r\n                    }\r\n                } else {  // if alive, stay alive if 1-4 neighbours, mazeCentric is 4\r\n                    if (curNode.wallNeighbours.length === 0 || curNode.wallNeighbours.length > 4) {\r\n                        curNode.setWall(false);\r\n                        oneFrame.push(curNode);\r\n                        neverChange = false;\r\n                    }\r\n                }\r\n            }\r\n        }\r\n        if (!neverChange) yield new Frame(oneFrame);\r\n        else c = MAX_LOAD;\r\n    }\r\n    return;\r\n}\r\n\r\nexport function * CATest(allNodes) {\r\n\r\n    // https://www.conwaylife.com/wiki/OCA:Maze\r\n    //  rulestring B3/S12345)\r\n\r\n    const numRows = allNodes.length;\r\n    const numCols = allNodes[0].length;\r\n\r\n    let allNodesCopy = allNodes.map(i => i.map(n => n.makeCopy()));\r\n\r\n    // ======================== random start? ========================\r\n\r\n    const startFrameNodes = [];\r\n    const lrMid = between(0, numCols - 1);\r\n    const udMid = between(0, numRows - 1);\r\n    const randNum = randBetween(5, 7);\r\n    for (let i = 0; i < randNum; i++) {\r\n        const randRow = randBetween(udMid - 1, udMid + 2);\r\n        const randCol = randBetween(lrMid - 1, lrMid + 2);\r\n        if (allNodesCopy[randRow][randCol].isWall) {\r\n            i --;\r\n            continue;\r\n        }\r\n        allNodesCopy[randRow][randCol].setWall(true);\r\n        startFrameNodes.push(allNodesCopy[randRow][randCol]);\r\n    }\r\n    yield new Frame(startFrameNodes, Frame.WALL);\r\n\r\n    // ======================== CA? ========================\r\n\r\n    let neverChange;\r\n    let curNode;\r\n    let oneFrame;\r\n\r\n    // 1, 1-4 interesting\r\n\r\n    for (let c = 0; c < MAX_LOAD; c++) {\r\n        // console.log(c);\r\n        neverChange = true;\r\n        oneFrame = [];\r\n        genAll(allNodesCopy);  // regenerate neighbours\r\n        for (let i = 0; i < numRows; i++) {\r\n            for (let j = 0; j < numCols; j++) {\r\n                curNode = allNodesCopy[i][j];\r\n                \r\n                // if dead, and have 3 live neighbours, come alive\r\n                if (!curNode.isWall) {\r\n                    if (curNode.wallNeighbours.length === 1) {\r\n                        curNode.setWall(true);\r\n                        oneFrame.push(curNode);\r\n                        neverChange = false;\r\n                    }\r\n                } else {  // if alive, stay alive if 1-4 neighbours, mazeCentric is 4, maze is 5\r\n                    if (curNode.wallNeighbours.length === 0 || curNode.wallNeighbours.length > 3) {\r\n                        curNode.setWall(false);\r\n                        oneFrame.push(curNode);\r\n                        neverChange = false;\r\n                    }\r\n                }\r\n            }\r\n        }\r\n        if (!neverChange) yield new Frame(oneFrame);\r\n        else c = MAX_LOAD;\r\n    }\r\n    return;\r\n}\r\n\r\nexport function * fillDeadEnds(allNodes) {\r\n\r\n    const numRows = allNodes.length;\r\n    const numCols = allNodes[0].length;\r\n\r\n    let allNodesCopy = allNodes.map(i => i.map(n => n.makeCopy()));\r\n\r\n    for (let i = 0; i < numRows; i++) {\r\n        for (let j = 0; j < numCols; j++) {\r\n            allNodesCopy[i][j].generateNeighbours(allNodesCopy, false);\r\n        }\r\n    }\r\n\r\n    let changed;\r\n    let thisFrame;\r\n    while (true) {\r\n        for (let i = 0; i < numRows; i++) {\r\n            for (let j = 0; j < numCols; j++) {\r\n                allNodesCopy[i][j].generateNeighbours(allNodesCopy, false);\r\n            }\r\n        }\r\n        changed = false;\r\n        thisFrame = [];\r\n        for (let i = 0; i < numRows; i++) {\r\n            for (let j = 0; j < numCols; j++) {\r\n                const curNode = allNodesCopy[i][j];\r\n                if (!curNode.isStart && !curNode.isEnd && !curNode.isWall && curNode.neighbours.length === 1) {  // is not a wall, only 1 neighbour\r\n                    allNodesCopy[i][j].setWall(true);\r\n                    thisFrame.push(allNodesCopy[i][j]);\r\n                    changed = true;\r\n                }\r\n            }\r\n        }\r\n        if (!changed) break;\r\n        yield new Frame(thisFrame, Frame.WALL);\r\n    }\r\n}\r\n\r\n\r\nexport function randCA(allNodes) {\r\n\r\n    const numRows = allNodes.length;\r\n    const numCols = allNodes[0].length;\r\n    const displayFrames = [];\r\n\r\n    let allNodesCopy = allNodes.map(i => i.map(n => n.makeCopy()));\r\n\r\n    function genAll(nodes) {\r\n        for (let i = 0; i < numRows; i++) {\r\n            for (let j = 0; j < numCols; j++) {\r\n                nodes[i][j].genWallNeighbours(nodes, true);\r\n            }\r\n        }\r\n        return nodes;\r\n    }\r\n\r\n    genAll(allNodesCopy);\r\n\r\n    const startFrameNodes = [];\r\n    for (let i = 0; i < 20; i++) {  // 20 random \r\n        const randRow = randBetween(0, numRows);\r\n        const randCol = randBetween(0, numCols);\r\n        allNodesCopy[randRow][randCol].setWall(true);\r\n        startFrameNodes.push(allNodesCopy[randRow][randCol]);\r\n    }\r\n    displayFrames.push(new Frame(startFrameNodes, Frame.WALL));\r\n\r\n    // lets try\r\n    \r\n    for (let c = 0; c < 20; c++) {\r\n        const oneFrame = [];\r\n        genAll(allNodesCopy);  // regenerate neighbours\r\n        for (let i = 0; i < numRows; i++) {\r\n            for (let j = 0; j < numCols; j++) {\r\n                if (allNodesCopy[i][j].wallNeighbours.length >= 1 && allNodesCopy[i][j].wallNeighbours.length <= 2) {\r\n                    if (Math.random() < 0.1) {\r\n                        allNodesCopy[i][j].setWall(true);\r\n                        oneFrame.push(allNodesCopy[i][j]);\r\n                    }\r\n                }\r\n            }\r\n        }\r\n        displayFrames.push(new Frame(oneFrame));\r\n    }\r\n\r\n    return displayFrames;\r\n}\r\n\r\n\r\nexport function randMaze(allNodes) {\r\n\r\n    const numRows = allNodes.length;\r\n    const numCols = allNodes[0].length;\r\n\r\n    let displayFrames = [];\r\n\r\n    function fillRow(rowOrColNum, left, right, up, down) {\r\n        let nodesToChange = [];\r\n        for (let j = left; j < right; j++) {\r\n            // nodesToChange.push(allNodes[rowNum][j]);\r\n            nodesToChange.push(new Frame([allNodes[rowOrColNum][j]], Frame.WALL));\r\n        }\r\n        // remove random one\r\n        // delete nodesToChange[randBetween(left, right)];\r\n        nodesToChange.splice(randBetween(left+1, between(left+1, right-1)), 1);\r\n        nodesToChange.splice(randBetween(between(left+1, right-1), right-1), 1);\r\n        displayFrames = displayFrames.concat(nodesToChange);\r\n        // return nodesToChange.map(n => new Frame([n], Frame.WALL));\r\n        // return new Frame(nodesToChange, Frame.WALL);\r\n    }\r\n\r\n    function fillCol(rowOrColNum, left, right, up, down) {\r\n        const nodesToChange = [];\r\n        for (let i = up; i < down; i++) {\r\n            // nodesToChange.push(allNodes[i][colNum]);\r\n            nodesToChange.push(new Frame([allNodes[i][rowOrColNum]], Frame.WALL));\r\n        }\r\n        // remove random one\r\n        // delete nodesToChange[randBetween(up, down)];\r\n        nodesToChange.splice(randBetween(up+1, between(up+1, down-1)), 1);\r\n        nodesToChange.splice(randBetween(between(up+1, down-1), down-1), 1);\r\n        displayFrames = displayFrames.concat(nodesToChange);\r\n    }\r\n\r\n    function helper(rowOrColNum, l, r, u, d, doRow) {\r\n        // console.log(`${rowOrColNum} ${l} ${r} ${u} ${d}`);\r\n        // if (l+1 === rowOrColNum || rowOrColNum+1 ==) return;\r\n        if (doRow) {\r\n            if (u + 1 >= rowOrColNum || rowOrColNum + 1 >= d) return;\r\n            fillRow(rowOrColNum, l, r, u, d);\r\n            // helper(l + between(l, r), l, r, u, rowOrColNum, !doRow);\r\n            // helper(l + between(l, r), l, r, rowOrColNum+1, d, !doRow);\r\n            const y = between(l, r);\r\n            helper(l + y, l, r, u, rowOrColNum-2, !doRow);\r\n            helper(l + y, l, r, rowOrColNum+2, d, !doRow);\r\n        } else {\r\n            if (l + 1 >= rowOrColNum || rowOrColNum + 1 >= r) return;\r\n            fillCol(rowOrColNum, l, r, u, d);\r\n            const y = between(u, d);\r\n            // helper(u + between(u, d), l, rowOrColNum, u, d, !doRow);\r\n            // helper(u + between(u, d), rowOrColNum+1, r, u, d, !doRow);\r\n            helper(u + y, l, rowOrColNum-2, u, d, !doRow);\r\n            helper(u + y, rowOrColNum+2, r, u, d, !doRow);\r\n        }\r\n    }\r\n\r\n    helper(between(0, numRows), 0, numCols, 0, numRows, true);\r\n\r\n    return displayFrames;\r\n}","import React from \"react\";\n\nimport classes from \"./App.module.css\";\n\nimport Grid from \"./components/Grid\";\nimport Node from \"./components/Node\";\nimport {bfs, bestFirstSearch, aStar} from \"./Algorithms/PathfindingAlgorithms\";\nimport {manhattanDistance, euclideanDistance} from \"./Algorithms/PathfindingAlgorithms\";\nimport {binaryTree, randomTree, CAMaze, CAMazeCetric, fillDeadEnds, CATest} from \"./Algorithms/MazeGeneratingAlgorithms\";\n\nimport Button from \"./components/Button\";\nimport Modal from \"./components/Modal\";\n\n\nconst ROWS = 31;\nconst COLUMNS = 41;\nconst SPEED = 10;\n\nconst allNodesB = [];\nfor (let i = 0; i < ROWS; i++) {\n    const newRow = [];\n    for (let j = 0; j < COLUMNS; j++) {\n        newRow.push(new Node(ROWS, COLUMNS, i, j));\n    }\n    allNodesB.push(newRow);\n}\n\n// function deepCopy(allNodes) {\n//   return allNodes.map(i => i.map(n => n.makeCopy()));\n// }\n\nfunction App() {\n\n  const [enableInput, setEnableInput] = React.useState(true);\n  const [allNodes, setAllNodes] = React.useState(allNodesB);\n  const [startNode, setStartNode] = React.useState(null);\n  const [endNode, setEndNode] = React.useState(null);\n\n  function updateSingleNode(node) {\n    const newAll = allNodes.slice();\n    newAll[node.rowNum][node.colNum] = node;\n    setAllNodes(newAll);\n  }\n\n  function updateFrameNodes(frameOfNodes) {  // takes in a frame of nodes\n    // console.log(frameOfNodes);\n    if (!frameOfNodes) return;\n    // console.log(frameOfNodes.getNodes());\n    if (frameOfNodes.instruction) {\n      frameOfNodes.execute();\n    }\n    const newAll = allNodes.slice();\n    const nodesToUpdate = frameOfNodes.getNodes().slice();\n    for (const n of nodesToUpdate) {\n        newAll[n.rowNum][n.colNum] = n;\n    }\n    setAllNodes(newAll);\n  }\n\n  function clearAll(event) {\n    if (!enableInput) return;\n    const newAll = allNodes.slice();\n    for (let i = 0; i < ROWS; i++) {\n      for (let j = 0; j < COLUMNS; j++) {\n        newAll[i][j].reset();\n      }\n    }\n    setAllNodes(newAll);\n    setStartNode(null);\n    setEndNode(null);\n  }\n\n  function clearWalls() {\n    const newAll = allNodes.slice();\n    for (let i = 0; i < ROWS; i++) {\n      for (let j = 0; j < COLUMNS; j++) {\n        newAll[i][j].setWall(false);\n      }\n    }\n    setAllNodes(newAll);\n  }\n\n  function clearPaths() {\n    const newAll = allNodes.slice();\n    for (let i = 0; i < ROWS; i++) {\n      for (let j = 0; j < COLUMNS; j++) {\n        newAll[i][j].unpath();\n      }\n    }\n    setAllNodes(newAll);\n  }\n\n  function generateNeighbours(diag) {\n    const newNodes = allNodes.slice();\n    for (let i = 0; i < ROWS; i++) {\n      for (let j = 0; j < COLUMNS; j++) {\n        newNodes[i][j].generateNeighbours(newNodes, diag);\n      }\n    }\n    setAllNodes(newNodes);\n  }\n\n  function startPathfinding(event) {\n    if (!enableInput) return;\n    if (startNode && endNode) {\n      clearPaths();\n      generateNeighbours(allowDiagonal);\n      startNode.generateNeighbours(allNodes, allowDiagonal);  // ZZZZZZ\n      const [searchFrames, pathFrames] = selectedAlgo(startNode, endNode, allNodes, selectedHf);\n      visualise(searchFrames, pathFrames);\n    }\n  } \n\n  function visualise(searchFrames, pathFrames) {\n    const numFrames = searchFrames.length;\n    for (let i = 0; i < numFrames; i++) {  // for each frame\n      setTimeout(() => {\n        updateFrameNodes(searchFrames[i]);\n        setEnableInput(false);\n      }, i*SPEED);\n    }\n\n    if (!pathFrames) pathFrames = [];\n\n    for (let i = 0; i < pathFrames.length; i++) {\n      setTimeout(\n      () => {\n        setEnableInput(false); \n        updateFrameNodes(pathFrames[i]);\n      }, \n      (searchFrames.length + i) * SPEED\n      );\n    }\n    setTimeout(\n      () => setEnableInput(true), \n      SPEED * (searchFrames.length + pathFrames.length)\n    );\n  }\n\n  const [selectedAlgoName, setAlgo] = React.useState(\"Best First Search\");\n  const pfNameToFunc = {\n    \"BFS\": bfs,\n    \"Best First Search\": bestFirstSearch,\n    \"A* Search\": aStar\n  }\n  const selectedAlgo = pfNameToFunc[selectedAlgoName];\n  \n  const [selectedHfName, setHf] = React.useState(\"Manhattan Distance\");\n  const hfNameToFunc = {\n    \"Manhattan Distance\": manhattanDistance,\n    \"Euclidean Distance\": euclideanDistance,\n  }\n  const selectedHf = hfNameToFunc[selectedHfName];\n\n  const [allowDiagonal, setAllowDiagonal] = React.useState(false);\n\n  const [showModal, setShowModal] = React.useState(false);\n\n  const modalMessage = `\n  Click on a grid square to set the start and end points. \\n\n  Start -> Green \\n\n  End -> Red \\n\n  Wall -> Black \\n\n  To reset a grid square, click on it again.  \\n\n  You can also left-click and drag to draw walls quickly, or right-click and drag to delete walls quickly. \n  `;\n\n  const genMaze = genFunc => {\n    if (!enableInput) return;\n    clearWalls();\n    clearPaths();\n\n    const displayFrames = genFunc(allNodes);\n    let result = displayFrames.next();\n    let i;\n    for (i = 0; !result.done; i++) {\n      ((r, iter) => \n        setTimeout(() => {\n          updateFrameNodes(r.value);\n          setEnableInput(false);\n        }, iter * SPEED)\n      )(result, i);\n      result = displayFrames.next();\n    }\n    \n    setTimeout(\n      () => {setEnableInput(true);}, \n      SPEED * i\n    );\n  }\n\n  const fillDead = event => {\n    if (!enableInput) return;\n    clearPaths();\n    const displayFrames = fillDeadEnds(allNodes);\n    let result = displayFrames.next();\n    let i;\n    for (i = 0; !result.done; i++) {\n\n      ((r, iter) => \n        setTimeout(() => {\n          updateFrameNodes(r.value);\n          setEnableInput(false);\n        }, iter * SPEED)\n      )(result, i);\n      result = displayFrames.next();\n\n      if (result.done) {\n        setTimeout(\n          () => {setEnableInput(true);}, \n          SPEED * i\n        );\n        return;\n      }\n    }\n   \n\n  }\n\n  return (\n    <div className={classes.mainDiv}>\n\n      {showModal && <Modal onConfirm={e => setShowModal(false)} title=\"Instructions\" message={modalMessage} />}\n\n      <div className={classes.topDiv}>\n       \n        <div className={classes.section}>\n          <Button onClick={e => setShowModal(true)} width=\"100px\" value=\"Instructions\"></Button>\n          <Button onClick={clearAll} value=\"Clear All\" disabled={!enableInput}></Button>\n        </div>\n\n        <div className={classes.section}>\n          {Object.keys(pfNameToFunc).map(name => <Button \n            onClick={() => setAlgo(name)}\n            width=\"100px\"\n            value={name} \n            key={name}\n            selected={selectedAlgoName===name} />)\n          }\n        </div>\n        \n        <div className={classes.section}>\n          {Object.keys(hfNameToFunc).map(name => <Button \n            onClick={() => setHf(name)}\n            width=\"120px\"\n            height=\"60px\" \n            value={name} \n            key={name}\n            selected={selectedHfName===name} />)\n          }\n        </div>\n\n        <div className={classes.section}>\n          <Button \n            onClick={() => setAllowDiagonal(p=>!p)} \n            width=\"120px\"\n            height=\"60px\" \n            value=\"Diagonal Travel\"\n            selected={allowDiagonal}/>\n        </div>\n\n        <div className={classes.section}>\n          <Button onClick={startPathfinding} value=\"Start\" disabled={!enableInput}></Button>\n        </div>\n\n      </div>\n\n      <Grid\n        ROWS={ROWS}\n        COLUMNS={COLUMNS}\n\n        enableInput={enableInput}\n\n        allNodes={allNodes}\n        startNode={startNode}\n        setStartNode={setStartNode}\n        endNode={endNode}\n        setEndNode={setEndNode}\n\n        updateNode={updateSingleNode}\n        />\n\n      <div className={classes.topDiv}>\n        <div className={classes.section}>\n          <Button onClick={e => genMaze(binaryTree)} value=\"Binary Tree\" disabled={!enableInput}></Button>\n          <Button onClick={e => genMaze(randomTree)} value=\"Random Tree\" disabled={!enableInput}></Button>\n          <Button onClick={e => genMaze(CAMaze)} width=\"100px\" value=\"Maze (CA)\" disabled={!enableInput}></Button>\n          <Button onClick={e => genMaze(CAMazeCetric)} width=\"100px\" value=\"MazeCetric (CA)\" disabled={!enableInput}></Button>\n          <Button onClick={e => genMaze(CATest)} width=\"100px\" value=\"Another CA\" disabled={!enableInput}></Button>\n        </div>\n\n        <div className={classes.section}>\n          <Button onClick={fillDead} value=\"Fill Dead Ends\" disabled={!enableInput}></Button>\n        </div>\n      </div>\n\n\n    </div>\n\n  );\n}\n\nexport default App;\n","import React from \"react\";\r\nimport classes from \"./Button.module.css\";\r\n\r\n\r\nconst Button = props => {\r\n\r\n    const height = props.height ? props.height : \"80px\";\r\n    const width = props.width ? props.width : \"80px\";\r\n\r\n    const buttonStyle = {\r\n        \"width\": width,\r\n        \"height\": height,\r\n        \"border\": props.border,\r\n    }\r\n\r\n    return (<div className={\r\n            `${props.hidden ? classes.hidden : \"\"} \r\n            ${classes.buttonClass} \r\n            ${props.selected ? classes.selected : \"\"}\r\n            ${props.disabled ? classes.disabled : \"\"}`}\r\n        style={buttonStyle} \r\n        onClick={props.onClick}>\r\n\r\n            {props.value}\r\n\r\n        </div>);\r\n}\r\n\r\nexport default Button;","import ReactDOM from \"react-dom\";\r\n\r\nimport Button from \"./Button\";\r\nimport classes from \"./Modal.module.css\";\r\n\r\nconst Backdrop = props => {\r\n    return <div className={classes.backdrop} onClick={props.onConfirm}></div>;\r\n};\r\n\r\nconst ModalOverlay = props => {\r\n    return (\r\n        <div className={classes.modal}>\r\n            <header className={classes.header}>\r\n                <h2>\r\n                    {props.title}\r\n                </h2>\r\n            </header>\r\n            <div className={classes.content}>\r\n                <p>\r\n                    {props.message.split(\"\\n\").map(x => <p>{x}</p>)}\r\n                </p>\r\n            </div>\r\n            <footer className={classes.actions}>\r\n                <Button onClick={props.onConfirm}>Ok!</Button>\r\n            </footer>\r\n        </div>\r\n    );\r\n};\r\n\r\nconst Modal = props => {\r\n    return (\r\n        <>\r\n            {ReactDOM.createPortal(<Backdrop onConfirm={props.onConfirm} />, document.getElementById(\"backdrop-root\"))}\r\n            {ReactDOM.createPortal(<ModalOverlay title={props.title} message={props.message} onConfirm={props.onConfirm}/>, document.getElementById(\"overlay-root\"))}\r\n        </>\r\n    );\r\n};\r\n\r\nexport default Modal;","const reportWebVitals = onPerfEntry => {\n  if (onPerfEntry && onPerfEntry instanceof Function) {\n    import('web-vitals').then(({ getCLS, getFID, getFCP, getLCP, getTTFB }) => {\n      getCLS(onPerfEntry);\n      getFID(onPerfEntry);\n      getFCP(onPerfEntry);\n      getLCP(onPerfEntry);\n      getTTFB(onPerfEntry);\n    });\n  }\n};\n\nexport default reportWebVitals;\n","import React from 'react';\nimport ReactDOM from 'react-dom';\nimport './index.css';\nimport App from './App';\nimport reportWebVitals from './reportWebVitals';\n\nReactDOM.render(\n  <React.StrictMode>\n    <App />\n  </React.StrictMode>,\n  document.getElementById('root')\n);\n\n// If you want to start measuring performance in your app, pass a function\n// to log results (for example: reportWebVitals(console.log))\n// or send to an analytics endpoint. Learn more: https://bit.ly/CRA-vitals\nreportWebVitals();\n"],"sourceRoot":""}